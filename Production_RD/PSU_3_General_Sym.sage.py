"""
A collection of combinatorial power maps that allow for the general (i.e., in terms of q) calculation of the dimension of the 2nd, 3rd, and 
4th Symmetric powers of the smallest non-trivial irreducible representation of PSU(3,q).
"""


# This file was *autogenerated* from the file PSU_3_General_Sym.sage
from sage.all_cmdline import *   # import sage library

_sage_const_3 = Integer(3); _sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_0 = Integer(0); _sage_const_6 = Integer(6); _sage_const_4 = Integer(4); _sage_const_9 = Integer(9); _sage_const_12 = Integer(12); _sage_const_5 = Integer(5); _sage_const_7 = Integer(7); _sage_const_11 = Integer(11); _sage_const_10 = Integer(10); _sage_const_8 = Integer(8); _sage_const_24 = Integer(24); _sage_const_36 = Integer(36); _sage_const_72 = Integer(72)
from sympy import sympify


# These functions need to be combined into a class with modulus as an attribute. 
class sym_object: 
    def __init__(self, modulus, power):
        self.power = power
        self.modulus = modulus
        self.q = var('q')
        self.d = gcd(_sage_const_3 , self.modulus + _sage_const_1 )
        self.r = self.q+_sage_const_1 
        self.s = self.q-_sage_const_1  
        self.t = self.q**_sage_const_2  - self.q + _sage_const_1 
        self.rp = self.r/self.d
        self.sp = self.s/self.d
        self.tp = self.t/self.d
        self.dp = (_sage_const_3 -self.d)/_sage_const_2 
        self.rpp = _sage_const_0  
        self.tpp = (self.tp - _sage_const_1 )/_sage_const_6  

        self.families = ['1', '2', '3^l', '4^k', '5^k', "6'", "6^klm", "7^k", "8^k"]
        self.num_classes = {'1': _sage_const_1 , '2': _sage_const_1 , '3^l': self.d, '4^k': self.rp - _sage_const_1 , '5^k': self.rp - _sage_const_1 , "6'": _sage_const_1  - self.dp, "6^klm": self.tpp - self.rpp, "7^k": self.tpp - self.rpp - self.dp, "8^k": _sage_const_2 *self.tpp}
        self.centralizers = {'1': self.q**_sage_const_3  * self.rp * self.r * self.s * self.t, '2': self.q**_sage_const_3  * self.rp, '3^l': self.q**_sage_const_2 , '4^k': self.q*self.rp*self.r*self.s, '5^k': self.q*self.rp, "6'": self.r**_sage_const_2 , "6^klm": self.rp*self.r, "7^k": self.rp*self.s, "8^k": self.tp}
        self.class_sizes = {key: (self.q**_sage_const_3  * self.rp * self.r * self.s * self.t) / val for key, val in self.centralizers.items()}
        self.character_val = {'1': self.q*self.s, '2': -_sage_const_1  * self.q, '3^l': _sage_const_0 , '4^k': -_sage_const_1  * self.s, '5^k': _sage_const_1 , "6'": _sage_const_2 , "6^klm": _sage_const_2 , "7^k": _sage_const_0 , "8^k": -_sage_const_1 }
    def C_1_power(self):
        if self.power == _sage_const_2 :
            C1Counter = _sage_const_1 
            C2Counter = _sage_const_0 
            C3Counter = _sage_const_0 
            C4Counter = _sage_const_0 
            C5Counter = _sage_const_0 
            C6pCounter = _sage_const_0 
            C6klmCounter = _sage_const_0 
            C7Counter = _sage_const_0 
            C8Counter = _sage_const_0 
            return (C1Counter, C2Counter, C3Counter, C4Counter, C5Counter, C6pCounter, C6klmCounter, C7Counter, C8Counter)
        if self.power == _sage_const_3 :
            C1Counter = _sage_const_1 
            C2Counter = _sage_const_0 
            C3Counter = _sage_const_0 
            C4Counter = _sage_const_0 
            C5Counter = _sage_const_0 
            C6pCounter = _sage_const_0 
            C6klmCounter = _sage_const_0 
            C7Counter = _sage_const_0 
            C8Counter = _sage_const_0 
            return (C1Counter, C2Counter, C3Counter, C4Counter, C5Counter, C6pCounter, C6klmCounter, C7Counter, C8Counter)
        if self.power == _sage_const_4 :
            C1Counter = _sage_const_1 
            C2Counter = _sage_const_0 
            C3Counter = _sage_const_0 
            C4Counter = _sage_const_0 
            C5Counter = _sage_const_0 
            C6pCounter = _sage_const_0 
            C6klmCounter = _sage_const_0 
            C7Counter = _sage_const_0 
            C8Counter = _sage_const_0 
            return (C1Counter, C2Counter, C3Counter, C4Counter, C5Counter, C6pCounter, C6klmCounter, C7Counter, C8Counter)

    def C_2_power(self):
        if self.power == _sage_const_2 :
            C1Counter = _sage_const_0 
            C2Counter = _sage_const_1 
            C3Counter = _sage_const_0 
            C4Counter = _sage_const_0 
            C5Counter = _sage_const_0 
            C6pCounter = _sage_const_0 
            C6klmCounter = _sage_const_0 
            C7Counter = _sage_const_0 
            C8Counter = _sage_const_0 
            if self.modulus % _sage_const_2  == _sage_const_0 :
                C1Counter += _sage_const_1 
                C2Counter -= _sage_const_1 
            return (C1Counter, C2Counter, C3Counter, C4Counter, C5Counter, C6pCounter, C6klmCounter, C7Counter, C8Counter)
        if self.power == _sage_const_3 :
            C1Counter = _sage_const_0 
            C2Counter = _sage_const_1 
            C3Counter = _sage_const_0 
            C4Counter = _sage_const_0 
            C5Counter = _sage_const_0 
            C6pCounter = _sage_const_0 
            C6klmCounter = _sage_const_0 
            C7Counter = _sage_const_0 
            C8Counter = _sage_const_0 
            if self.modulus % _sage_const_3  == _sage_const_0 :
                C1Counter += _sage_const_1 
                C2Counter -= _sage_const_1 
            return (C1Counter, C2Counter, C3Counter, C4Counter, C5Counter, C6pCounter, C6klmCounter, C7Counter, C8Counter)
        if self.power == _sage_const_4 :
            C1Counter = _sage_const_0 
            C2Counter = _sage_const_1 
            C3Counter = _sage_const_0 
            C4Counter = _sage_const_0 
            C5Counter = _sage_const_0 
            C6pCounter = _sage_const_0 
            C6klmCounter = _sage_const_0 
            C7Counter = _sage_const_0 
            C8Counter = _sage_const_0 
            if self.modulus % _sage_const_2  == _sage_const_0 :
                C1Counter += _sage_const_1 
                C2Counter -= _sage_const_1 
            return (C1Counter, C2Counter, C3Counter, C4Counter, C5Counter, C6pCounter, C6klmCounter, C7Counter, C8Counter)

    def C_3_power(self):
        if self.power == _sage_const_2 :
            C1Counter = _sage_const_0 
            C2Counter = _sage_const_0 
            C3Counter = self.d
            C4Counter = _sage_const_0 
            C5Counter = _sage_const_0 
            C6pCounter = _sage_const_0 
            C6klmCounter = _sage_const_0 
            C7Counter = _sage_const_0 
            C8Counter = _sage_const_0 
            if self.modulus % _sage_const_2  == _sage_const_0 :
                C2Counter += self.d
                C3Counter -= self.d
            return (C1Counter, C2Counter, C3Counter, C4Counter, C5Counter, C6pCounter, C6klmCounter, C7Counter, C8Counter)
        if self.power == _sage_const_3 :
            C1Counter = _sage_const_0 
            C2Counter = _sage_const_0 
            C3Counter = self.d
            C4Counter = _sage_const_0 
            C5Counter = _sage_const_0 
            C6pCounter = _sage_const_0 
            C6klmCounter = _sage_const_0 
            C7Counter = _sage_const_0 
            C8Counter = _sage_const_0 
            if self.modulus % _sage_const_3  == _sage_const_0 :
                C1Counter += self.d
                C3Counter -= self.d
            return (C1Counter, C2Counter, C3Counter, C4Counter, C5Counter, C6pCounter, C6klmCounter, C7Counter, C8Counter)
        if self.power == _sage_const_4 :
            C1Counter = _sage_const_0 
            C2Counter = _sage_const_0 
            C3Counter = self.d
            C4Counter = _sage_const_0 
            C5Counter = _sage_const_0 
            C6pCounter = _sage_const_0 
            C6klmCounter = _sage_const_0 
            C7Counter = _sage_const_0 
            C8Counter = _sage_const_0 
            if self.modulus % _sage_const_2  == _sage_const_0 :
                C1Counter += self.d
                C3Counter -= self.d
            return (C1Counter, C2Counter, C3Counter, C4Counter, C5Counter, C6pCounter, C6klmCounter, C7Counter, C8Counter)

    def C_4_power(self):
        if self.power == _sage_const_2 :
            C1Counter = _sage_const_0 
            C4Counter = (self.q+_sage_const_1 )/self.d-_sage_const_1 
            C2Counter = _sage_const_0 
            C3Counter = _sage_const_0 
            C5Counter = _sage_const_0 
            C6pCounter = _sage_const_0 
            C6klmCounter = _sage_const_0 
            C7Counter = _sage_const_0 
            C8Counter = _sage_const_0 
            if self.modulus % _sage_const_2  == _sage_const_1 :
                C1Counter += _sage_const_1 
                C4Counter -= _sage_const_1 
            return (C1Counter, C2Counter, C3Counter, C4Counter, C5Counter, C6pCounter, C6klmCounter, C7Counter, C8Counter)

        if self.power == _sage_const_3 :
            C1Counter = _sage_const_0 
            C4Counter = (self.q+_sage_const_1 )/self.d-_sage_const_1 
            C2Counter = _sage_const_0 
            C3Counter = _sage_const_0 
            C5Counter = _sage_const_0 
            C6pCounter = _sage_const_0 
            C6klmCounter = _sage_const_0 
            C7Counter = _sage_const_0 
            C8Counter = _sage_const_0 
            if (self.modulus + _sage_const_1 ) % _sage_const_9  == _sage_const_0 : # going to need the mod we're dealing with to be divisible by 9
                C1Counter += _sage_const_2 
                C4Counter -= _sage_const_2 
            return (C1Counter, C2Counter, C3Counter, C4Counter, C5Counter, C6pCounter, C6klmCounter, C7Counter, C8Counter)

        if self.power == _sage_const_4 :
            C1Counter = _sage_const_0 
            C4Counter = (self.q+_sage_const_1 )/self.d-_sage_const_1 
            C2Counter = _sage_const_0 
            C3Counter = _sage_const_0 
            C5Counter = _sage_const_0 
            C6pCounter = _sage_const_0 
            C6klmCounter = _sage_const_0 
            C7Counter = _sage_const_0 
            C8Counter = _sage_const_0 
            if (self.modulus + _sage_const_1 ) % _sage_const_4  == _sage_const_0 : 
                C1Counter += _sage_const_3 
                C4Counter -= _sage_const_3 
            elif (self.modulus + _sage_const_1 ) % _sage_const_2  == _sage_const_0 :
                C1Counter += _sage_const_1 
                C4Counter -= _sage_const_1 
            return (C1Counter, C2Counter, C3Counter, C4Counter, C5Counter, C6pCounter, C6klmCounter, C7Counter, C8Counter)

    def C_5_power(self):
        if self.power == _sage_const_2 :
            C1Counter = _sage_const_0 
            C2Counter = _sage_const_0 
            C3Counter = _sage_const_0 
            C4Counter = _sage_const_0 
            C5Counter = (self.q+_sage_const_1 )/self.d-_sage_const_1 
            C6pCounter = _sage_const_0 
            C6klmCounter = _sage_const_0 
            C7Counter = _sage_const_0 
            C8Counter = _sage_const_0 
            if self.modulus % _sage_const_2  == _sage_const_1 :
                C2Counter +=_sage_const_1 
                C5Counter -= _sage_const_1 
            if self.modulus % _sage_const_2  == _sage_const_0 :
                C4Counter += (self.q+_sage_const_1 )/self.d-_sage_const_1 
                C5Counter -= (self.q+_sage_const_1 )/self.d-_sage_const_1 
            return (C1Counter, C2Counter, C3Counter, C4Counter, C5Counter, C6pCounter, C6klmCounter, C7Counter, C8Counter)
        if self.power == _sage_const_3 :
            C1Counter = _sage_const_0 
            C2Counter = _sage_const_0 
            C3Counter = _sage_const_0 
            C4Counter = _sage_const_0 
            C5Counter = (self.q+_sage_const_1 )/self.d-_sage_const_1 
            C6pCounter = _sage_const_0 
            C6klmCounter = _sage_const_0 
            C7Counter = _sage_const_0 
            C8Counter = _sage_const_0 
            if (self.modulus+_sage_const_1 ) % _sage_const_9  == _sage_const_0 : # need self.modulus divisible by 9
                C2Counter += _sage_const_2 
                C5Counter -= _sage_const_2 
            if self.modulus % _sage_const_3  == _sage_const_0 :
                C4Counter += (self.q+_sage_const_1 )/self.d-_sage_const_1 
                C5Counter-= (self.q+_sage_const_1 )/self.d-_sage_const_1  
            return (C1Counter, C2Counter, C3Counter, C4Counter, C5Counter, C6pCounter, C6klmCounter, C7Counter, C8Counter)

        if self.power == _sage_const_4 :
            C1Counter = _sage_const_0 
            C2Counter = _sage_const_0 
            C3Counter = _sage_const_0 
            C4Counter = _sage_const_0 
            C5Counter = (self.q+_sage_const_1 )/self.d-_sage_const_1 
            C6pCounter = _sage_const_0 
            C6klmCounter = _sage_const_0 
            C7Counter = _sage_const_0 
            C8Counter = _sage_const_0 
            if (self.modulus+_sage_const_1 ) % _sage_const_2  == _sage_const_0 :
                C2Counter += _sage_const_1 
                C5Counter -= _sage_const_1 
            if (self.modulus+_sage_const_1 ) % _sage_const_4  == _sage_const_0 :
                C2Counter += _sage_const_2 
                C5Counter -= _sage_const_2 
            if self.modulus % _sage_const_2  == _sage_const_0 :
                C4Counter += (self.q+_sage_const_1 )/self.d-_sage_const_1 
                C5Counter-= (self.q+_sage_const_1 )/self.d-_sage_const_1  
            return (C1Counter, C2Counter, C3Counter, C4Counter, C5Counter, C6pCounter, C6klmCounter, C7Counter, C8Counter)

    def C_6_p_power(self):
        if self.power == _sage_const_2 :
            C6pCounter = _sage_const_1 -(_sage_const_3 -self.d)/_sage_const_2 
            C1Counter = _sage_const_0 
            C2Counter = _sage_const_0 
            C3Counter = _sage_const_0 
            C4Counter = _sage_const_0 
            C5Counter = _sage_const_0 
            C6klmCounter = _sage_const_0 
            C7Counter = _sage_const_0 
            C8Counter = _sage_const_0 
            return (C1Counter, C2Counter, C3Counter, C4Counter, C5Counter, C6pCounter, C6klmCounter, C7Counter, C8Counter)
        if self.power == _sage_const_3 :
            C6pCounter = _sage_const_0 
            C1Counter = _sage_const_1 -(_sage_const_3 -self.d)/_sage_const_2 
            C2Counter = _sage_const_0 
            C3Counter = _sage_const_0 
            C4Counter = _sage_const_0 
            C5Counter = _sage_const_0 
            C6klmCounter = _sage_const_0 
            C7Counter = _sage_const_0 
            C8Counter = _sage_const_0 
            return (C1Counter, C2Counter, C3Counter, C4Counter, C5Counter, C6pCounter, C6klmCounter, C7Counter, C8Counter)
        if self.power == _sage_const_4 :
            C6pCounter = _sage_const_1 -(_sage_const_3 -self.d)/_sage_const_2 
            C1Counter = _sage_const_0 
            C2Counter = _sage_const_0 
            C3Counter = _sage_const_0 
            C4Counter = _sage_const_0 
            C5Counter = _sage_const_0 
            C6klmCounter = _sage_const_0 
            C7Counter = _sage_const_0 
            C8Counter = _sage_const_0 
            return (C1Counter, C2Counter, C3Counter, C4Counter, C5Counter, C6pCounter, C6klmCounter, C7Counter, C8Counter)

    def C_6_klm_power(self):
        if self.power == _sage_const_2 :
            if (self.modulus+_sage_const_1 ) % _sage_const_12  in [_sage_const_1 ,_sage_const_3 ,_sage_const_5 ,_sage_const_7 ,_sage_const_9 ,_sage_const_11 ]:
                C4Counter = _sage_const_0  
            if (self.modulus+_sage_const_1 ) % _sage_const_12  in [_sage_const_2 , _sage_const_10 ]:
                total = _sage_const_0  - ceil(self.r/_sage_const_4 ) + floor(self.r/_sage_const_6 ) + self.r/_sage_const_2   + ceil(floor(self.r/_sage_const_6 )/_sage_const_2 )
                C4Counter = total
            if (self.modulus+_sage_const_1 ) % _sage_const_12  in [_sage_const_4 , _sage_const_8 ]:
                total = -_sage_const_1  * floor(self.r/_sage_const_4 ) + floor(self.r/_sage_const_6 ) + self.r/_sage_const_2  + floor((ceil(self.r/_sage_const_6 ) - _sage_const_1 )/_sage_const_2 )
                C4Counter = total
            if (self.modulus+_sage_const_1 ) % _sage_const_12  == _sage_const_6 :
                C4Counter = self.r/_sage_const_6  - _sage_const_1 
            if (self.modulus+_sage_const_1 ) % _sage_const_12  == _sage_const_0 :
                C4Counter = self.r/_sage_const_6  - _sage_const_1  
            return (_sage_const_0 , _sage_const_0 , _sage_const_0 , C4Counter, _sage_const_0 , _sage_const_0 , self.tpp - self.rpp - C4Counter, _sage_const_0 , _sage_const_0 )

        if self.power == _sage_const_3 :
            C4Counter = _sage_const_0 
            a = (self.modulus + _sage_const_1 ) % _sage_const_12 
            if a%_sage_const_3  != _sage_const_0 :
                pass
            if a%_sage_const_6  == _sage_const_0 :
                # Case 2a
                C4Counter +=  (ceil(_sage_const_2 *self.r/_sage_const_9 ) - _sage_const_1 ) - ceil(self.r/_sage_const_6 ) + _sage_const_1 
                # Case 3a
                C4Counter += floor((ceil(_sage_const_2 *self.r/_sage_const_9 ) - _sage_const_1 )/_sage_const_2 )
                # Case 2a, 3a diff of 2r/3
                C4Counter += ceil(self.r/_sage_const_9 ) - _sage_const_1  
                C4Counter += floor((ceil(self.r/_sage_const_9 ) - _sage_const_1 )/_sage_const_2 )

            if a%_sage_const_6  == _sage_const_3 :
                # Case 2a
                C4Counter += (ceil(_sage_const_2 *self.r/_sage_const_9 ) - _sage_const_1 ) - ceil(self.r/_sage_const_6 ) + _sage_const_1 
                # Case 3a
                C4Counter += floor((ceil(_sage_const_2 *self.r/_sage_const_9 ) - _sage_const_1 )/_sage_const_2 )
                # Case 2a, 3a diff of 2r/3
                C4Counter += ceil(self.r/_sage_const_9 ) - _sage_const_1    
                C4Counter += ceil((ceil(self.r/_sage_const_9 ) - _sage_const_1 )/_sage_const_2 )
            return (_sage_const_0 , _sage_const_0 , _sage_const_0 , C4Counter, _sage_const_0 , _sage_const_0 , self.tpp - self.rpp - C4Counter, _sage_const_0 , _sage_const_0 )

        if self.power == _sage_const_4 :
            C4Counter = _sage_const_0 
            C1Counter = _sage_const_0 
            a = (self.modulus + _sage_const_1 ) % _sage_const_24  
            square_modulus = self.modulus % _sage_const_12 
            square_sym = sym_object(square_modulus, _sage_const_2 ) 
            C4Counter += square_sym.C_6_klm_power()[_sage_const_3 ]
            if a % _sage_const_4  != _sage_const_0 :
                pass
            elif a % _sage_const_3  != _sage_const_0 :
                # Case 1a
                C4Counter += ceil(self.r/_sage_const_6 ) - _sage_const_1 
                # Case 1b
                C4Counter += ceil(self.r/_sage_const_2 ) - _sage_const_1  - ceil(_sage_const_3 *self.r/_sage_const_8 ) + _sage_const_1 
                # Case 2a
                C4Counter += ceil(self.r/_sage_const_4 ) - _sage_const_1  - ceil(self.r/_sage_const_6 ) + _sage_const_1 
                # Case 2b
                C4Counter += ceil(_sage_const_7 *self.r/_sage_const_12 ) - _sage_const_1  - (floor(self.r/_sage_const_2 ) + _sage_const_1 ) + _sage_const_1  
                # Case 3a 
                if a % _sage_const_8  == _sage_const_0 :
                    C4Counter += floor((ceil(self.r/_sage_const_4 ) - _sage_const_1 )/_sage_const_2 )
                if a % _sage_const_8  == _sage_const_4 :
                    C4Counter += ceil((ceil(self.r/_sage_const_4 ) - _sage_const_1 )/_sage_const_2 )
                # Case 3b
                if a % _sage_const_8  == _sage_const_0 :
                    C4Counter += ceil((ceil(self.r*_sage_const_7 /_sage_const_12 ) - _sage_const_1  - ceil(self.r/_sage_const_4 ) + _sage_const_1 )/_sage_const_2 )
                if a % _sage_const_8  == _sage_const_4 :
                    C4Counter += ceil((ceil(self.r*_sage_const_7 /_sage_const_12 ) - _sage_const_1  - ceil(self.r/_sage_const_4 ) + _sage_const_1 )/_sage_const_2 )
                # diff of 3r/4
                # Case 1b
                C4Counter += ceil(self.r/_sage_const_6 ) - _sage_const_1  - ceil(self.r/_sage_const_8 ) + _sage_const_1  
                # Case 2a
                C4Counter += ceil(self.r/_sage_const_12 ) - _sage_const_1 
                # Case 2b
                C4Counter += ceil(self.r/_sage_const_4 ) - ceil(self.r/_sage_const_6 ) + _sage_const_1  
                # Case 3a
                if a % _sage_const_8  == _sage_const_0 :
                    C4Counter += floor(floor(self.r/_sage_const_12 )/_sage_const_2 )
                elif a % _sage_const_8  == _sage_const_4 :
                    C4Counter += ceil(floor(self.r/_sage_const_12 )/_sage_const_2 )
                C4Counter -= _sage_const_3 
                C1Counter += _sage_const_1 
            elif a % _sage_const_3  == _sage_const_0 :
                # Case 1a 
                C4Counter += ceil(self.r/_sage_const_12 )
                # Case 2a
                C4Counter += ceil(self.r/_sage_const_4 ) - _sage_const_1  - ceil(_sage_const_5 *self.r/_sage_const_24 ) + _sage_const_1 
                # Case 3a
                if a % _sage_const_8  == _sage_const_0 :
                    C4Counter += floor((ceil(self.r/_sage_const_4 ) - _sage_const_1  - ceil(self.r/_sage_const_12 ) + _sage_const_1 )/_sage_const_2 )
                elif a % _sage_const_8  == _sage_const_4 :
                    C4Counter += ceil((ceil(self.r/_sage_const_4 ) - _sage_const_1  - ceil(self.r/_sage_const_12 ) + _sage_const_1 )/_sage_const_2 )
                # diff of 3r/4
                # Case 2a
                C4Counter += ceil(self.r/_sage_const_12 ) - _sage_const_1 
                # Case 3a 
                if a % _sage_const_8  == _sage_const_0 :
                    C4Counter += floor(floor(self.r/_sage_const_12 )/_sage_const_2 )
                elif a % _sage_const_8  == _sage_const_4 :
                    C4Counter += ceil(floor(self.r/_sage_const_12 )/_sage_const_2 )
                C4Counter -= _sage_const_4 
                C1Counter += _sage_const_1 
            return (C1Counter, _sage_const_0 , _sage_const_0 , C4Counter, _sage_const_0 , _sage_const_0 , self.tpp - self.rpp - C4Counter - C1Counter, _sage_const_0 , _sage_const_0 )

    def C_7_power(self):
        if self.power == _sage_const_2 :
            totalnum = (_sage_const_3 *self.tpp - self.rpp - self.dp) 
            C1Counter = _sage_const_0 
            C2Counter = _sage_const_0 
            C3Counter = _sage_const_0 
            C4Counter = _sage_const_0 
            C5Counter = _sage_const_0 
            C6pCounter = _sage_const_0 
            C6klmCounter = _sage_const_0 
            C7Counter = totalnum
            C8Counter = _sage_const_0 
            if self.modulus % _sage_const_2  != _sage_const_0 :
                C4Counter += (self.q+_sage_const_1 )/(_sage_const_2 *self.d)
                C7Counter = C7Counter - (self.q+_sage_const_1 )/(_sage_const_2 *self.d)
            return (C1Counter, C2Counter, C3Counter, C4Counter, C5Counter, C6pCounter, C6klmCounter, C7Counter, C8Counter)

        if self.power == _sage_const_3 :
            totalnum = (_sage_const_3 *self.tpp - self.rpp - self.dp)
            C1Counter = _sage_const_0 
            C2Counter = _sage_const_0 
            C3Counter = _sage_const_0 
            C4Counter = _sage_const_0 
            C5Counter = _sage_const_0 
            C6pCounter = _sage_const_0 
            C6klmCounter = _sage_const_0 
            C7Counter = totalnum
            C8Counter = _sage_const_0 
            if self.modulus % _sage_const_3  == _sage_const_1 :
                C1Counter += _sage_const_1 
                C7Counter -= _sage_const_1 
                C4Counter += self.q
                C7Counter -= self.q
            return (C1Counter, C2Counter, C3Counter, C4Counter, C5Counter, C6pCounter, C6klmCounter, C7Counter, C8Counter)

        if self.power == _sage_const_4 :
            totalnum = (self.q*self.q-self.q+_sage_const_1 -self.d)/(_sage_const_2 *self.d) - (_sage_const_3 -self.d)/_sage_const_2 
            C1Counter = _sage_const_0 
            C2Counter = _sage_const_0 
            C3Counter = _sage_const_0 
            C4Counter = _sage_const_0 
            C5Counter = _sage_const_0 
            C6pCounter = _sage_const_0 
            C6klmCounter = _sage_const_0 
            C7Counter = totalnum
            C8Counter = _sage_const_0 
            if self.modulus % _sage_const_2  == _sage_const_1 :
                C4Counter += (self.q+_sage_const_1 )/(_sage_const_2 *self.d)
                C7Counter -= (self.q+_sage_const_1 )/(_sage_const_2 *self.d)
            if (self.modulus+_sage_const_1 )%_sage_const_2  == _sage_const_0  and (self.modulus+_sage_const_1 )%_sage_const_4  != _sage_const_0 :
                C1Counter += _sage_const_1 
                C4Counter -= _sage_const_1 
            if self.modulus % _sage_const_4  == _sage_const_1 :
                C4Counter += _sage_const_2 *(self.q+_sage_const_1 )/(_sage_const_2 *self.d)
                C7Counter -= _sage_const_2 *(self.q+_sage_const_1 )/(_sage_const_2 *self.d)
            return (C1Counter, C2Counter, C3Counter, C4Counter, C5Counter, C6pCounter, C6klmCounter, C7Counter, C8Counter)

    def C_8_power(self):
        if self.power == _sage_const_2 :
            C1Counter = _sage_const_0 
            C2Counter = _sage_const_0 
            C3Counter = _sage_const_0 
            C4Counter = _sage_const_0 
            C5Counter = _sage_const_0 
            C6pCounter = _sage_const_0 
            C6klmCounter = _sage_const_0 
            C7Counter = _sage_const_0 
            C8Counter = ((self.q*self.q-self.q+_sage_const_1 )/self.d-_sage_const_1 )/_sage_const_3 
            return (C1Counter, C2Counter, C3Counter, C4Counter, C5Counter, C6pCounter, C6klmCounter, C7Counter, C8Counter)

        if self.power == _sage_const_3 :
            C1Counter = _sage_const_0 
            C2Counter = _sage_const_0 
            C3Counter = _sage_const_0 
            C4Counter = _sage_const_0 
            C5Counter = _sage_const_0 
            C6pCounter = _sage_const_0 
            C6klmCounter = _sage_const_0 
            C7Counter = _sage_const_0 
            C8Counter = ((self.q*self.q-self.q+_sage_const_1 )/self.d-_sage_const_1 )/_sage_const_3 
            return (C1Counter, C2Counter, C3Counter, C4Counter, C5Counter, C6pCounter, C6klmCounter, C7Counter, C8Counter)

        if self.power == _sage_const_4 :
            C1Counter = _sage_const_0 
            C2Counter = _sage_const_0 
            C3Counter = _sage_const_0 
            C4Counter = _sage_const_0 
            C5Counter = _sage_const_0 
            C6pCounter = _sage_const_0 
            C6klmCounter = _sage_const_0 
            C7Counter = _sage_const_0 
            C8Counter = ((self.q*self.q-self.q+_sage_const_1 )/self.d-_sage_const_1 )/_sage_const_3 
            return (C1Counter, C2Counter, C3Counter, C4Counter, C5Counter, C6pCounter, C6klmCounter, C7Counter, C8Counter)
    
    def get_power_map_counts(self):
        maps = {}
        families = ['1', '2', '3^l', '4^k', '5^k', "6'", "6^klm", "7^k", "8^k"]
        maps['1'] = dict(zip(families, self.C_1_power()))
        maps['2'] = dict(zip(families, self.C_2_power()))
        maps['3^l'] = dict(zip(families, self.C_3_power()))
        maps['4^k'] = dict(zip(families, self.C_4_power()))
        maps['5^k'] = dict(zip(families, self.C_5_power()))
        maps["6'"] = dict(zip(families, self.C_6_p_power()))
        maps["6^klm"] = dict(zip(families, self.C_6_klm_power()))
        maps["7^k"] = dict(zip(families, self.C_7_power()))
        maps["8^k"] = dict(zip(families, self.C_8_power()))
        mod_needed = {_sage_const_2 : _sage_const_12 , _sage_const_3 : _sage_const_36 , _sage_const_4 : _sage_const_72 }
        for key in maps.keys():
            for key2 in maps:
                k = var('k')
                assume(k, 'integer')
                assume(k >= _sage_const_0 )
                
                if str(type(maps[key][key2].subs(q=(self.modulus + mod_needed[self.power]*k)))) == "<class 'sage.symbolic.expression.Expression'>":
                    maps[key][key2] = maps[key][key2].subs(q=(self.modulus + mod_needed[self.power]*k)).full_simplify().subs(k=(q-self.modulus)/mod_needed[self.power]).full_simplify()
                # print(total.subs(q=(modulus + 72*k)).full_simplify().subs(k=(q-modulus)/72).full_simplify())
        return maps
    def calc_sym_power(self):
        
        total = _sage_const_0 
        if self.power == _sage_const_2 :
            square_maps = self.get_power_map_counts()
            for family in self.families:
                total += self.class_sizes[family]*self.num_classes[family]*(self.character_val[family] ** _sage_const_2 )
                for fam2 in self.families: # iterate through the maps 
                    total += self.class_sizes[family]*self.character_val[fam2]*square_maps[family][fam2]
            total = (total/_sage_const_2 )/(self.q**_sage_const_3  * self.rp * self.r * self.s * self.t)
        if self.power == _sage_const_3 :
            self_sym_squared = sym_object(self.modulus % _sage_const_12 , _sage_const_2 )
            square_maps = self_sym_squared.get_power_map_counts()
            cube_maps = self.get_power_map_counts()
            for family in self.families:
                total += self.class_sizes[family]*self.num_classes[family]*(self.character_val[family] ** _sage_const_3 )
                for fam2 in self.families: # iterate through the square maps 
                    total += self.class_sizes[family]*self.character_val[fam2]* square_maps[family][fam2] * _sage_const_3  * self.character_val[family]
                    total += self.class_sizes[family]*self.character_val[fam2]* cube_maps[family][fam2] * _sage_const_2  
            total = (total/_sage_const_6 )/(self.q**_sage_const_3  * self.rp * self.r * self.s * self.t)
        if self.power == _sage_const_4 :
            self_sym_squared = sym_object(self.modulus % _sage_const_12 , _sage_const_2 )
            square_maps = self_sym_squared.get_power_map_counts()
            self_sym_cubed = sym_object(self.modulus % _sage_const_36 , _sage_const_3 )
            cube_maps = self_sym_cubed.get_power_map_counts()
            fourth_maps = self.get_power_map_counts()
            for family in self.families:
                total += self.class_sizes[family]*self.num_classes[family]*(self.character_val[family] ** _sage_const_4 )
                for fam2 in self.families: # iterate through the square maps 
                    total += self.class_sizes[family]*self.character_val[fam2]* square_maps[family][fam2] * (self.character_val[family] ** _sage_const_2 ) * _sage_const_6 
                    total += self.class_sizes[family]*(self.character_val[fam2]** _sage_const_2 ) * square_maps[family][fam2] * _sage_const_3  
                    total += self.class_sizes[family]*self.character_val[fam2]* cube_maps[family][fam2] * self.character_val[family] * _sage_const_8 
                    total += self.class_sizes[family]*self.character_val[fam2]*fourth_maps[family][fam2] * _sage_const_6 
            total = (total/_sage_const_24 )/(self.q**_sage_const_3  * self.rp * self.r * self.s * self.t)
        return total.full_simplify()

for i in range(_sage_const_36 ):
    group = sym_object(i, _sage_const_3 )
    print(group.calc_sym_power())
raise SystemExit


dict_list = []
for modulus in range(_sage_const_0 , _sage_const_12 ):
    q = var('q')
    d = gcd(_sage_const_3 , modulus + _sage_const_1 )
    r = q+_sage_const_1 
    s = q-_sage_const_1  
    t = q**_sage_const_2  - q + _sage_const_1 
    rp = r/d
    sp = s/d
    tp = t/d
    dp = (_sage_const_3 -d)/_sage_const_2 
    rpp = _sage_const_0  
    tpp = (tp - _sage_const_1 )/_sage_const_6  


    square_maps = get_power_map_counts(_sage_const_2 , modulus)
    families = ['1', '2', '3^l', '4^k', '5^k', "6'", "6^klm", "7^k", "8^k"]
    num_classes = {'1': _sage_const_1 , '2': _sage_const_1 , '3^l': d, '4^k': rp - _sage_const_1 , '5^k': rp - _sage_const_1 , "6'": _sage_const_1  - dp, "6^klm": tpp - rpp, "7^k": tpp - rpp - dp, "8^k": _sage_const_2 *tpp}
    centralizers = {'1': q**_sage_const_3  * rp * r * s * t, '2': q**_sage_const_3  * rp, '3^l': q**_sage_const_2 , '4^k': q*rp*r*s, '5^k': q*rp, "6'": r**_sage_const_2 , "6^klm": rp*r, "7^k": rp*s, "8^k": tp}
    class_sizes = {key: (q**_sage_const_3  * rp * r * s * t) / val for key, val in centralizers.items()}
    character_val = {'1': q*s, '2': -_sage_const_1  * q, '3^l': _sage_const_0 , '4^k': -_sage_const_1  * s, '5^k': _sage_const_1 , "6'": _sage_const_2 , "6^klm": _sage_const_2 , "7^k": _sage_const_0 , "8^k": -_sage_const_1 }
    total = _sage_const_0 
    for family in families:
        total += class_sizes[family]*num_classes[family]*(character_val[family] ** _sage_const_2 )
        for fam2 in families: # iterate through the square maps 
            total += class_sizes[family]*character_val[fam2]* square_maps[family][fam2]
    total = (total/_sage_const_2 )/(q**_sage_const_3  * rp * r * s * t)
    print("==========================================")
    print(f"for modulus: {modulus}")
    print(total.full_simplify()) 
    print(square_maps)
    print("==========================================")

    for key in square_maps.keys():
            for key2 in square_maps:
                k = var('k')
                assume(k, 'integer')
                assume(k >= _sage_const_0 )
                if str(type(square_maps[key][key2].subs(q=(modulus + _sage_const_36 *k)))) == "<class 'sage.symbolic.expression.Expression'>":
                    square_maps[key][key2] = square_maps[key][key2].subs(q=(modulus + _sage_const_36 *k)).full_simplify().subs(k=(q-modulus)/_sage_const_36 ).full_simplify()
                # print(total.subs(q=(modulus + 72*k)).full_simplify().subs(k=(q-modulus)/72).full_simplify())
    dict_list.append(square_maps)
                # fourth_maps_eval[key][key2] = fourth_maps[key][key2].subs(q=modulus) 

unique_elements = []
for d in dict_list:
    if d not in unique_elements:
        unique_elements.append(d)
print(len(dict_list))
print(len(unique_elements))

dict_assignment = []
for dict1 in unique_elements:
    dict_assignment.append([])
    for i, dict2 in enumerate(dict_list):
        if dict2 == dict1:
            dict_assignment[-_sage_const_1 ].append(i)
print(dict_assignment)
print(unique_elements)
raise SystemExit

# print(equations)
# print(equations_list)


# Prepare the data for SymPy
for table_data in unique_elements:
    for row_dict in table_data.values():
        for key, value in row_dict.items():
            if value == 'q':
                row_dict[key] = 'q'
            elif isinstance(value, str):
                row_dict[key] = value.replace('^', '**')

    latex_table = create_latex_table([table_data])
    print(latex_table)


dict_list = []
for modulus in range(_sage_const_0 ,_sage_const_36 ):
    q = var('q')
    d = gcd(_sage_const_3 , modulus + _sage_const_1 )
    r = q+_sage_const_1 
    s = q-_sage_const_1  
    t = q**_sage_const_2  - q + _sage_const_1 
    rp = r/d
    sp = s/d
    tp = t/d
    dp = (_sage_const_3 -d)/_sage_const_2 
    rpp = _sage_const_0  
    tpp = (tp - _sage_const_1 )/_sage_const_6  

    square_maps = get_power_map_counts(_sage_const_2 , modulus)
    cube_maps = get_power_map_counts(_sage_const_3 , modulus)
    families = ['1', '2', '3^l', '4^k', '5^k', "6'", "6^klm", "7^k", "8^k"]
    num_classes = {'1': _sage_const_1 , '2': _sage_const_1 , '3^l': d, '4^k': rp - _sage_const_1 , '5^k': rp - _sage_const_1 , "6'": _sage_const_1  - dp, "6^klm": tpp - rpp, "7^k": tpp - rpp - dp, "8^k": _sage_const_2 *tpp}
    centralizers = {'1': q**_sage_const_3  * rp * r * s * t, '2': q**_sage_const_3  * rp, '3^l': q**_sage_const_2 , '4^k': q*rp*r*s, '5^k': q*rp, "6'": r**_sage_const_2 , "6^klm": rp*r, "7^k": rp*s, "8^k": tp}
    class_sizes = {key: (q**_sage_const_3  * rp * r * s * t) / val for key, val in centralizers.items()}
    character_val = {'1': q*s, '2': -_sage_const_1  * q, '3^l': _sage_const_0 , '4^k': -_sage_const_1  * s, '5^k': _sage_const_1 , "6'": _sage_const_2 , "6^klm": _sage_const_2 , "7^k": _sage_const_0 , "8^k": -_sage_const_1 }
    total = _sage_const_0 
    for family in families:
        total += class_sizes[family]*num_classes[family]*(character_val[family] ** _sage_const_3 )
        for fam2 in families: # iterate through the square maps 
            total += class_sizes[family]*character_val[fam2]* square_maps[family][fam2] * _sage_const_3  * character_val[family]
            total += class_sizes[family]*character_val[fam2]* cube_maps[family][fam2] * _sage_const_2  
    total = (total/_sage_const_6 )/(q**_sage_const_3  * rp * r * s * t)
    print("==========================================")
    print(f"for modulus: {modulus}")
    print(total.full_simplify()) 
    """
    if modulus != 0 and modulus != 1:
        print(total.subs(q=(modulus)))
    equations[modulus] = str(total.full_simplify())
    equations_list.append(str(total.full_simplify()))
    if modulus % 9 == 8:
        cube_maps_eval = {}
        for key in cube_maps.keys():
            cube_maps_eval[key] = {}
            for key2 in cube_maps:
                cube_maps_eval[key][key2] = cube_maps[key][key2].subs(q=modulus) 
        print(cube_maps_eval)
    """
    for key in cube_maps.keys():
        for key2 in cube_maps:
            k = var('k')
            assume(k, 'integer')
            assume(k >= _sage_const_0 )
            if str(type(cube_maps[key][key2].subs(q=(modulus + _sage_const_36 *k)))) == "<class 'sage.symbolic.expression.Expression'>":
                cube_maps[key][key2] = cube_maps[key][key2].subs(q=(modulus + _sage_const_36 *k)).full_simplify().subs(k=(q-modulus)/_sage_const_36 ).full_simplify()
            # print(total.subs(q=(modulus + 72*k)).full_simplify().subs(k=(q-modulus)/72).full_simplify())
    dict_list.append(cube_maps)
            # fourth_maps_eval[key][key2] = fourth_maps[key][key2].subs(q=modulus) 
    print(cube_maps)
    print("==========================================")

unique_elements = []
for d in dict_list:
    if d not in unique_elements:
        unique_elements.append(d)
print(len(dict_list))
print(len(unique_elements))

dict_assignment = []
for dict1 in unique_elements:
    dict_assignment.append([])
    for i, dict2 in enumerate(dict_list):
        if dict2 == dict1:
            dict_assignment[-_sage_const_1 ].append(i)
print(dict_assignment)
print(unique_elements)

# print(equations)
# print(equations_list)


# Prepare the data for SymPy
for table_data in unique_elements:
    for row_dict in table_data.values():
        for key, value in row_dict.items():
            if value == 'q':
                row_dict[key] = 'q'
            elif isinstance(value, str):
                row_dict[key] = value.replace('^', '**')

    latex_table = create_latex_table([table_data])
    print(latex_table)
dict_list = []
for modulus in range(_sage_const_0 , _sage_const_72 ):
    q = var('q')
    d = gcd(_sage_const_3 , modulus + _sage_const_1 )
    r = q+_sage_const_1 
    s = q-_sage_const_1  
    t = q**_sage_const_2  - q + _sage_const_1 
    rp = r/d
    sp = s/d
    tp = t/d
    dp = (_sage_const_3 -d)/_sage_const_2 
    rpp = _sage_const_0  
    tpp = (tp - _sage_const_1 )/_sage_const_6  

    square_maps = get_power_map_counts(_sage_const_2 , modulus)
    cube_maps = get_power_map_counts(_sage_const_3 , modulus)
    fourth_maps = get_power_map_counts(_sage_const_4 , modulus)
    families = ['1', '2', '3^l', '4^k', '5^k', "6'", "6^klm", "7^k", "8^k"]
    num_classes = {'1': _sage_const_1 , '2': _sage_const_1 , '3^l': d, '4^k': rp - _sage_const_1 , '5^k': rp - _sage_const_1 , "6'": _sage_const_1  - dp, "6^klm": tpp - rpp, "7^k": tpp - rpp - dp, "8^k": _sage_const_2 *tpp}
    centralizers = {'1': q**_sage_const_3  * rp * r * s * t, '2': q**_sage_const_3  * rp, '3^l': q**_sage_const_2 , '4^k': q*rp*r*s, '5^k': q*rp, "6'": r**_sage_const_2 , "6^klm": rp*r, "7^k": rp*s, "8^k": tp}
    class_sizes = {key: (q**_sage_const_3  * rp * r * s * t) / val for key, val in centralizers.items()}
    character_val = {'1': q*s, '2': -_sage_const_1  * q, '3^l': _sage_const_0 , '4^k': -_sage_const_1  * s, '5^k': _sage_const_1 , "6'": _sage_const_2 , "6^klm": _sage_const_2 , "7^k": _sage_const_0 , "8^k": -_sage_const_1 }
    total = _sage_const_0 
    for family in families:
        total += class_sizes[family]*num_classes[family]*(character_val[family] ** _sage_const_4 )
        for fam2 in families: # iterate through the square maps 
            total += class_sizes[family]*character_val[fam2]* square_maps[family][fam2] * (character_val[family] ** _sage_const_2 ) * _sage_const_6 
            total += class_sizes[family]*(character_val[fam2]** _sage_const_2 ) * square_maps[family][fam2] * _sage_const_3  
            total += class_sizes[family]*character_val[fam2]* cube_maps[family][fam2] * character_val[family] * _sage_const_8 
            total += class_sizes[family]*character_val[fam2]*fourth_maps[family][fam2] * _sage_const_6 
    total = (total/_sage_const_24 )/(q**_sage_const_3  * rp * r * s * t)
    print("==========================================")
    print(f"for modulus: {modulus}")
    print(total.full_simplify()) 
    print(total.subs(q=(modulus + _sage_const_72 )))
    print(fourth_maps)
    k = var('k')
    assume(k, 'integer')
    assume(k >= _sage_const_0 )
    print(total.subs(q=(modulus + _sage_const_72 *k)).full_simplify().subs(k=(q-modulus)/_sage_const_72 ).full_simplify())
    # equations[modulus] = str(total.full_simplify())
    # equations_list.append(str(total.full_simplify()))
    print("==========================================")
    for key in fourth_maps.keys():
        for key2 in fourth_maps:
            k = var('k')
            assume(k, 'integer')
            assume(k >= _sage_const_0 )
            if str(type(fourth_maps[key][key2].subs(q=(modulus + _sage_const_72 *k)))) == "<class 'sage.symbolic.expression.Expression'>":
                fourth_maps[key][key2] = fourth_maps[key][key2].subs(q=(modulus + _sage_const_72 *k)).full_simplify().subs(k=(q-modulus)/_sage_const_72 ).full_simplify()
            # print(total.subs(q=(modulus + 72*k)).full_simplify().subs(k=(q-modulus)/72).full_simplify())
    dict_list.append(fourth_maps)
            # fourth_maps_eval[key][key2] = fourth_maps[key][key2].subs(q=modulus) 
    # print(fourth_maps)
    print("==========================================")

unique_elements = []
for d in dict_list:
    if d not in unique_elements:
        unique_elements.append(d)
print(len(dict_list))
print(len(unique_elements))

dict_assignment = []
for dict1 in unique_elements:
    dict_assignment.append([])
    for i, dict2 in enumerate(dict_list):
        if dict2 == dict1:
            dict_assignment[-_sage_const_1 ].append(i)
print(dict_assignment)
print(unique_elements)
for table_data in unique_elements:
    for row_dict in table_data.values():
        for key, value in row_dict.items():
            if value == 'q':
                row_dict[key] = 'q'
            elif isinstance(value, str):
                row_dict[key] = value.replace('^', '**')

    latex_table = create_latex_table([table_data])
    print(latex_table)

