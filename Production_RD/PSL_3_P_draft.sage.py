

# This file was *autogenerated* from the file PSL_3_P_draft.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_4 = Integer(4); _sage_const_5 = Integer(5); _sage_const_7 = Integer(7); _sage_const_8 = Integer(8); _sage_const_6 = Integer(6); _sage_const_50 = Integer(50); _sage_const_9 = Integer(9); _sage_const_12 = Integer(12); _sage_const_11 = Integer(11); _sage_const_10 = Integer(10); _sage_const_24 = Integer(24); _sage_const_47 = Integer(47)
from math import gcd
import time

load("group_characters.sage")
class GroupCharactersPSL3(GroupCharacters):
    q = _sage_const_1  # q as seen in PSL(3, q)
    p = _sage_const_0  # the characteristic of the field
    d = _sage_const_0 
    r = _sage_const_0 
    s = _sage_const_0 
    t = _sage_const_0 
    tp = _sage_const_0 
    rp = _sage_const_0  
    name = ""
    classes = []
    class_order = {}
    centralizer_order = {}
    group_order = _sage_const_0 
    primes = []
    power_map = {}
    characters = []
    minimal_perm = _sage_const_0 
    name = ""
    class_initialization_time = _sage_const_0  
    character_table_time = _sage_const_0 


    def __init__(self, prime, exp):
        self.start_pm_time = time.time()
        ### useful constants
        q = prime**exp
        p = prime
        d = gcd(_sage_const_3 ,q-_sage_const_1 )
        r = q-_sage_const_1 
        s = q+_sage_const_1 
        t = q**_sage_const_2 +q+_sage_const_1 
        rp = r//d
        tp = t//d
        
        self.q = q
        self.p = p 
        self.dc = d
        self.tp = tp
        self.rp = rp
        self.s = s
        self.r = r
        self.t = t
        self.d = d 

        self.group_order = q**_sage_const_3 *r*rp*s*t
        self.exp = exp

        self.name = f"PSL({prime},{exp}) (prime, exp)"
        self.class_initialization()
        self.characters_initalization()


    def class_initialization(self):
        q = self.q
        p = self.p
        d = self.d
        r = self.r 
        s = self.s  
        t = self.t 
        rp = self.rp  
        tp = self.tp  

        ### conjugacy classes, class orders, and centralizer orders
        self.classes = [ "C_1", "C_2" ] # C1 & C2 initialization
        self.class_order["C_1"] = _sage_const_1 
        self.centralizer_order["C_1"] = q**_sage_const_3 *rp*r*s*t
        self.class_order["C_2"] = p
        self.centralizer_order["C_2"] = q**_sage_const_3 *rp

        # C_3^l initialization
        for l in range(d):
            c = f"C_3^{l}"
            self.classes.append(c)
            ### These class_orders are conjectured but not certain 
            if p == _sage_const_2 :
                self.class_order[c] = _sage_const_4 
            else:
                self.class_order[c] = p
            self.centralizer_order[c] = q**_sage_const_2 
        
        # C_4^k initialization
        for k in range(_sage_const_1 ,rp):
            c = f"C_4^{k}"
            self.classes.append(c)
            self.class_order[c] = rp//gcd(rp,k)
            self.centralizer_order[c] = q*rp*r*s

        # C_5^k initialization 
        for k in range(_sage_const_1 ,rp):
            c = f"C_5^{k}"
            self.classes.append(c)
            self.class_order[c] = _sage_const_0 
            self.centralizer_order[c] = q*rp
            n = _sage_const_1 
            while True: # this sucks, we should find a better way to do this
                if k*n % ((r)//d) == _sage_const_0  and n%p == _sage_const_0 :
                    self.class_order[c] = n
                    break
                n += _sage_const_1 
        # C_6' initialization
        if d == _sage_const_3 :
            self.classes.append("C_6'")
            self.class_order["C_6'"] = _sage_const_3 
            self.centralizer_order["C_6'"] = r**_sage_const_2 
        
        # C_6^klm initialization
        for l in range(_sage_const_2 ,rp+_sage_const_1 ): 
            for k in range(_sage_const_1 ,l):
                m = (-k-l)%r
                if m == _sage_const_0 :
                    m = r
                if l < m:
                    
                    c = f"C_6^{{{k},{l},{m}}}"
                    self.classes.append(c)
                    self.centralizer_order[c] = rp*r
                    self.class_order[c] = int(r / gcd(k,l,m,r))
        
        # C_7^k initialization
        klist = []
        for k in range(_sage_const_1 ,rp*s):
            if k%s == _sage_const_0 :
                continue
            k = min(k, ((-q*k) % (rp * s)))
            if k in klist:
                continue
            else: 
                klist.append(k)
            c = f"C_7^{k}" 
            self.classes.append(c)
            self.class_order[c] = rp*s // gcd(k, rp*s)
            self.centralizer_order[c] = rp*s
            
        # C_8^k initialization
        klist = []
        for k in range(_sage_const_1 ,tp):
            k = min(k, (-k * q) % tp, ((q ** _sage_const_2 ) * k) % tp )
            if k in klist:
                continue 
            else: 
                klist.append(k)
            c = f"C_8^{k}"
            self.classes.append(c)
            self.class_order[c] = tp
            self.centralizer_order[c] = tp

        self.class_initialization_time = time.time() - self.start_pm_time


    def characters_initalization(self):
        q = self.q
        p = self.p
        d = self.d
        r = self.r 
        s = self.s  
        t = self.t 
        rp = self.rp  
        tp = self.tp  

        ### compute relevant primes 
        # not necessary with our current approach
        # self.primes = primes_up_to(max(self.class_order.values()))

        ### compute power maps
        # this is NOT a good way to do it, but it'll do (for known powers) for now
        for g in self.classes:
            self.power_map[g] = {}
            #for p in self.primes:
            for p in [_sage_const_2 ,_sage_const_3 ,_sage_const_5 ,_sage_const_7 ]: # we only need primes up to the # of molien coefficients we're asking for.
                self.power_map[g][p] = self.power_of(g,p)

        ### implement characters of degree qs and t
        # Generates character table data for Chi_qs and Chi_t^(u)
        start_char_time = time.time()
        UCF = UniversalCyclotomicField() 
        eps = UCF.gen(r) # epsilon as an rth root of unity
        self.characters = [{} for u in range(rp)] 
        for g in self.classes:
            i = int(g[_sage_const_2 ]) 
            k,l,m = _sage_const_0 ,_sage_const_0 ,_sage_const_0  
            if i in [_sage_const_3 ,_sage_const_4 ,_sage_const_5 ,_sage_const_7 ,_sage_const_8 ]:
                k = int(g[_sage_const_4 :])
            elif i == _sage_const_6  and g[-_sage_const_1 ] != "'":
                k,l,m = map(int,g[_sage_const_5 :-_sage_const_1 ].split(','))
            
            # Chi_qs
            if i == _sage_const_1 : 
                self.characters[_sage_const_0 ][g] = q * s 
            elif i == _sage_const_2 : 
                self.characters[_sage_const_0 ][g] = q
            elif i == _sage_const_3 : 
                self.characters[_sage_const_0 ][g] = _sage_const_0  
            elif i == _sage_const_4 : 
                self.characters[_sage_const_0 ][g] = s
            elif i == _sage_const_5 : 
                self.characters[_sage_const_0 ][g] = _sage_const_1  
            elif i == _sage_const_6 : 
                self.characters[_sage_const_0 ][g] = _sage_const_2 
            elif i == _sage_const_7 : 
                self.characters[_sage_const_0 ][g] = _sage_const_0 
            elif i == _sage_const_8 : 
                self.characters[_sage_const_0 ][g] = -_sage_const_1 

            # Chi_t^u
            for u in range(_sage_const_1 ,rp):
                if i == _sage_const_1 : 
                    self.characters[u][g] = t 
                elif i == _sage_const_2 : 
                    self.characters[u][g] = s 
                elif i == _sage_const_3 : 
                    self.characters[u][g] = _sage_const_1 
                elif i == _sage_const_4 : 
                    self.characters[u][g] = s * eps**(_sage_const_3  * u * k) + eps**(-_sage_const_6  * u * k)  
                elif i == _sage_const_5 : 
                    self.characters[u][g] = eps**(_sage_const_3  * u * k) + eps**(-_sage_const_6  * u * k) 
                elif i == _sage_const_6  : 
                    if g[-_sage_const_1 ] == "'": 
                        self.characters[u][g] = _sage_const_3 
                    else: 
                        self.characters[u][g] = eps**(_sage_const_3  * u * k) + eps**(_sage_const_3  * u * l) + eps**(_sage_const_3  * u * m) 
                elif i == _sage_const_7 : 
                    self.characters[u][g] = -_sage_const_1  * eps**(_sage_const_3  * u * k) 
                elif i == _sage_const_8 : 
                    self.characters[u][g] = _sage_const_0  
        self.character_table_time = time.time() - start_char_time
            # return self.characters #end of check for our 2 chars 

        # determine minimal faithful perm representation
        if self.q == _sage_const_5 :
            self.minimal_perm = _sage_const_50 
        else:
            self.minimal_perm = self.q ** _sage_const_3  + _sage_const_1   


    def power_of(self, g, n):
        """
        Computes the conjugacy class of g^n
        """
        q = self.q
        d = self.d
        s = self.s
        r = self.r
        tp = self.tp
        rp = self.rp
        p = self.p
        i = int(g[_sage_const_2 ])

        # initialize
        k,l,m = _sage_const_0 ,_sage_const_0 ,_sage_const_0  

        # string handling to recover indices from string
        if i in [_sage_const_3 ,_sage_const_4 ,_sage_const_5 ,_sage_const_7 ,_sage_const_8 ]:
            k = int(g[_sage_const_4 :])
        elif i == _sage_const_6  and g[-_sage_const_1 ] != "'":
            k,l,m = map(int,g[_sage_const_5 :-_sage_const_1 ].split(','))

        # power map logic
        if i == _sage_const_1 :
            return "C_1"

        elif i == _sage_const_2 :
            if n%p == _sage_const_0 :
                return "C_1"
            return "C_2"

        elif i == _sage_const_3 :
            if self.p == _sage_const_2 :
                if n%_sage_const_4  == _sage_const_0 :
                    return "C_1"
                elif n%_sage_const_2  == _sage_const_0 :
                    return "C_2"
                else:
                    return g 
            else:
                if n%self.p == _sage_const_0 :
                    return "C_1"
                else:
                    return g 
                    
        elif i == _sage_const_4 :
            e = (n*k) % ((r)//d)
            if e == _sage_const_0 :
                return "C_1"
            else:
                return f"C_4^{e}"

        elif i == _sage_const_5 :
            if k*n % (rp) == _sage_const_0  and n%p == _sage_const_0  :
                return "C_1"
            elif k*n % (rp) == _sage_const_0 :
                return "C_2"
            elif n % p == _sage_const_0 :
                return f"C_4^{n * k % rp}" # added 7/15--might not  work
            return f"C_5^{k*n % (rp)}"

        elif i == _sage_const_6 :
            # Logic for C_6'
            if g[-_sage_const_1 ] == "'":
                if n%_sage_const_3  == _sage_const_0 :
                    return "C_1"
                return "C_6'"
            # Logic for C_6^{k,l,m}
            diag = [(n*x)%((r)) for x in (k,l,m)] # ((q+1)//d) ?
            k,l,m = sorted([ (r) if x == _sage_const_0  else x for x in diag])  # ((q+1)//d) ?

            if (k,l,m) == (rp, _sage_const_2  * (rp),  (r)): # checks for C_6'
                return "C_6'" 
            while l > rp:
                diag  = [(x + rp)%(r) for x in (k,l,m)]
                k,l,m = sorted([ (r) if x == _sage_const_0  else x for x in diag])
            if k == l or l == m: # broke the rules!
                return self.power_of(f"C_4^1", l) # what's up with this?
            return f"C_6^{{{k},{l},{m}}}"

        elif i == _sage_const_7 :
            if k*n % (s*rp) == _sage_const_0 :
                return "C_1"
            elif k*n % s == _sage_const_0 :
                return f"C_4^{sorted([s*k*n % (s*rp), k*n % (s*rp), (-q*k*n) % (s*rp)])[_sage_const_1 ] // s}"
            y = k*n % (s*rp)
            y = min(y, (-q*y) % (s*rp))
            return f"C_7^{y}"

        elif i == _sage_const_8 :
            if k*n % tp == _sage_const_0 :
                return "C_1"
            w = k*n % tp
            w = min(w, w*(q) % tp, w*q*q % tp) #changed this, it might break itself
            return f"C_8^{w}"
    
    def C_1_squared(self):
        """
        Returns a summary of the families that each conjugacy class in C_1 gets mapped to when it's squared.  
        """
        C1Counter = _sage_const_1 
        C2Counter = _sage_const_0 
        C3Counter = _sage_const_0 
        C4Counter = _sage_const_0 
        C5Counter = _sage_const_0 
        C6pCounter = _sage_const_0 
        C6klmCounter = _sage_const_0 
        C7Counter = _sage_const_0 
        C8Counter = _sage_const_0 
        return (C1Counter, C2Counter, C3Counter, C4Counter, C5Counter, C6pCounter, C6klmCounter, C7Counter, C8Counter)
    
    def C_1_cubed(self):
        """
        Returns a summary of the families that each conjugacy class in C_1 gets mapped to when it's cubed.  
        """
        C1Counter = _sage_const_1 
        C2Counter = _sage_const_0 
        C3Counter = _sage_const_0 
        C4Counter = _sage_const_0 
        C5Counter = _sage_const_0 
        C6pCounter = _sage_const_0 
        C6klmCounter = _sage_const_0 
        C7Counter = _sage_const_0 
        C8Counter = _sage_const_0 
        return (C1Counter, C2Counter, C3Counter, C4Counter, C5Counter, C6pCounter, C6klmCounter, C7Counter, C8Counter)

    def C_1_fourth(self):
        """
        Returns a summary of the families that each conjugacy class in C_1 gets mapped to when it's raised to the fourth power.  
        """
        C1Counter = _sage_const_1 
        C2Counter = _sage_const_0 
        C3Counter = _sage_const_0 
        C4Counter = _sage_const_0 
        C5Counter = _sage_const_0 
        C6pCounter = _sage_const_0 
        C6klmCounter = _sage_const_0 
        C7Counter = _sage_const_0 
        C8Counter = _sage_const_0 
        return (C1Counter, C2Counter, C3Counter, C4Counter, C5Counter, C6pCounter, C6klmCounter, C7Counter, C8Counter)
    
    def C_2_squared(self):
        """
        Returns a summary of the families that each conjugacy class in C_2 gets mapped to when it's squared.  
        """
        C1Counter = _sage_const_0 
        C2Counter = _sage_const_1 
        C3Counter = _sage_const_0 
        C4Counter = _sage_const_0 
        C5Counter = _sage_const_0 
        C6pCounter = _sage_const_0 
        C6klmCounter = _sage_const_0 
        C7Counter = _sage_const_0 
        C8Counter = _sage_const_0 
        p = self.p
        if p == _sage_const_2 :
            C1Counter += _sage_const_1 
            C2Counter -= _sage_const_1 
        return (C1Counter, C2Counter, C3Counter, C4Counter, C5Counter, C6pCounter, C6klmCounter, C7Counter, C8Counter)

    def C_2_cubed(self):
        """
        Returns a summary of the families that each conjugacy class in C_2 gets mapped to when it's cubed.  
        """
        C1Counter = _sage_const_0 
        C2Counter = _sage_const_1 
        C3Counter = _sage_const_0 
        C4Counter = _sage_const_0 
        C5Counter = _sage_const_0 
        C6pCounter = _sage_const_0 
        C6klmCounter = _sage_const_0 
        C7Counter = _sage_const_0 
        C8Counter = _sage_const_0 
        p = self.p
        if p == _sage_const_3 :
            C1Counter += _sage_const_1 
            C2Counter -= _sage_const_1 
        return (C1Counter, C2Counter, C3Counter, C4Counter, C5Counter, C6pCounter, C6klmCounter, C7Counter, C8Counter)

    def C_2_fourth(self):
        """
        Returns a summary of the families that each conjugacy class in C_2 gets mapped to when it's raised to the fourth power.  
        """
        C1Counter = _sage_const_0 
        C2Counter = _sage_const_1 
        C3Counter = _sage_const_0 
        C4Counter = _sage_const_0 
        C5Counter = _sage_const_0 
        C6pCounter = _sage_const_0 
        C6klmCounter = _sage_const_0 
        C7Counter = _sage_const_0 
        C8Counter = _sage_const_0 
        p = self.p
        if p == _sage_const_2 :
            C1Counter += _sage_const_1 
            C2Counter -= _sage_const_1 
        return (C1Counter, C2Counter, C3Counter, C4Counter, C5Counter, C6pCounter, C6klmCounter, C7Counter, C8Counter)

    def C_3_squared(self):
        """
        Returns a summary of the families that each conjugacy class in C_3 gets mapped to when it's squared.  
        """
        d = self.d
        p = self.p
        C1Counter = _sage_const_0 
        C2Counter = _sage_const_0 
        C3Counter = d
        C4Counter = _sage_const_0 
        C5Counter = _sage_const_0 
        C6pCounter = _sage_const_0 
        C6klmCounter = _sage_const_0 
        C7Counter = _sage_const_0 
        C8Counter = _sage_const_0 
        if p == _sage_const_2 :
            C2Counter += d
            C3Counter -= d
        return (C1Counter, C2Counter, C3Counter, C4Counter, C5Counter, C6pCounter, C6klmCounter, C7Counter, C8Counter)

    
    def C_3_cubed(self):
        """
        Returns a summary of the families that each conjugacy class in C_3 gets mapped to when it's cubed.  
        """
        d = self.d
        p = self.p
        C1Counter = _sage_const_0 
        C2Counter = _sage_const_0 
        C3Counter = d
        C4Counter = _sage_const_0 
        C5Counter = _sage_const_0 
        C6pCounter = _sage_const_0 
        C6klmCounter = _sage_const_0 
        C7Counter = _sage_const_0 
        C8Counter = _sage_const_0 
        if p == _sage_const_3 :
            C1Counter += d
            C3Counter -= d
        return (C1Counter, C2Counter, C3Counter, C4Counter, C5Counter, C6pCounter, C6klmCounter, C7Counter, C8Counter)

    
    def C_3_fourth(self):
        """
        Returns a summary of the families that each conjugacy class in C_3 gets mapped to when it's raised to the fourth power.  
        """
        d = self.d
        p = self.p
        C1Counter = _sage_const_0 
        C2Counter = _sage_const_0 
        C3Counter = d
        C4Counter = _sage_const_0 
        C5Counter = _sage_const_0 
        C6pCounter = _sage_const_0 
        C6klmCounter = _sage_const_0 
        C7Counter = _sage_const_0 
        C8Counter = _sage_const_0 
        if p == _sage_const_2 :
            C1Counter += d
            C3Counter -= d
        return (C1Counter, C2Counter, C3Counter, C4Counter, C5Counter, C6pCounter, C6klmCounter, C7Counter, C8Counter)

    def C_4_squared(self):
        """
        Returns a summary of the families that each conjugacy class in C_4 gets mapped to when it's squared.  
        """
        q = self.q
        d = self.d
        C1Counter = _sage_const_0 
        C4Counter = (q+_sage_const_1 )//d-_sage_const_1 
        C2Counter = _sage_const_0 
        C3Counter = _sage_const_0 
        C5Counter = _sage_const_0 
        C6pCounter = _sage_const_0 
        C6klmCounter = _sage_const_0 
        C7Counter = _sage_const_0 
        C8Counter = _sage_const_0 
        if q % _sage_const_2  == _sage_const_1 :
            C1Counter += _sage_const_1 
            C4Counter -= _sage_const_1 
        return (C1Counter, C2Counter, C3Counter, C4Counter, C5Counter, C6pCounter, C6klmCounter, C7Counter, C8Counter)

    def C_4_cubed(self):
        """
        Returns a summary of the families that each conjugacy class in C_4 gets mapped to when it's cubed.  
        """
        q = self.q
        d = self.d
        C1Counter = _sage_const_0 
        C4Counter = (q+_sage_const_1 )//d-_sage_const_1 
        C2Counter = _sage_const_0 
        C3Counter = _sage_const_0 
        C5Counter = _sage_const_0 
        C6pCounter = _sage_const_0 
        C6klmCounter = _sage_const_0 
        C7Counter = _sage_const_0 
        C8Counter = _sage_const_0 
        if (q+_sage_const_1 ) % _sage_const_9  == _sage_const_0 :
            C1Counter += _sage_const_2 
            C4Counter -= _sage_const_2 
        return (C1Counter, C2Counter, C3Counter, C4Counter, C5Counter, C6pCounter, C6klmCounter, C7Counter, C8Counter)

    def C_4_fourth(self):
        """
        Returns a summary of the families that each conjugacy class in C_4 gets mapped to when it's raised to the fourth power.  
        """
        q = self.q
        d = self.d
        C1Counter = _sage_const_0 
        C4Counter = (q+_sage_const_1 )//d-_sage_const_1 
        C2Counter = _sage_const_0 
        C3Counter = _sage_const_0 
        C5Counter = _sage_const_0 
        C6pCounter = _sage_const_0 
        C6klmCounter = _sage_const_0 
        C7Counter = _sage_const_0 
        C8Counter = _sage_const_0 
        if (q+_sage_const_1 ) % _sage_const_4  == _sage_const_0 : 
            C1Counter += _sage_const_3 
            C4Counter -= _sage_const_3 
        elif (q+_sage_const_1 ) % _sage_const_2  == _sage_const_0 :
            C1Counter += _sage_const_1 
            C4Counter -= _sage_const_1 
        return (C1Counter, C2Counter, C3Counter, C4Counter, C5Counter, C6pCounter, C6klmCounter, C7Counter, C8Counter)

    def C_5_squared(self):
        """
        Returns a summary of the families that each conjugacy class in C_5 gets mapped to when it's squared.  
        """
        q = self.q
        d = self.d
        p = self.p
        C1Counter = _sage_const_0 
        C2Counter = _sage_const_0 
        C3Counter = _sage_const_0 
        C4Counter = _sage_const_0 
        C5Counter = (q+_sage_const_1 )//d-_sage_const_1 
        C6pCounter = _sage_const_0 
        C6klmCounter = _sage_const_0 
        C7Counter = _sage_const_0 
        C8Counter = _sage_const_0 
        if q % _sage_const_2  == _sage_const_1 :
            C2Counter +=_sage_const_1 
            C5Counter -= _sage_const_1 
        if p == _sage_const_2 :
            C4Counter += (q+_sage_const_1 )//d-_sage_const_1 
            C5Counter -= (q+_sage_const_1 )//d-_sage_const_1 
        return (C1Counter, C2Counter, C3Counter, C4Counter, C5Counter, C6pCounter, C6klmCounter, C7Counter, C8Counter)

    def C_5_cubed(self):
        """
        Returns a summary of the families that each conjugacy class in C_5 gets mapped to when it's cubed.  
        """
        q = self.q
        d = self.d
        p = self.p
        C1Counter = _sage_const_0 
        C2Counter = _sage_const_0 
        C3Counter = _sage_const_0 
        C4Counter = _sage_const_0 
        C5Counter = (q+_sage_const_1 )//d-_sage_const_1 
        C6pCounter = _sage_const_0 
        C6klmCounter = _sage_const_0 
        C7Counter = _sage_const_0 
        C8Counter = _sage_const_0 
        if (q+_sage_const_1 ) % _sage_const_9  == _sage_const_0 :
            C2Counter += _sage_const_2 
            C5Counter -= _sage_const_2 
        if p == _sage_const_3 :
            C4Counter += (q+_sage_const_1 )//d-_sage_const_1 
            C5Counter-= (q+_sage_const_1 )//d-_sage_const_1  
        return (C1Counter, C2Counter, C3Counter, C4Counter, C5Counter, C6pCounter, C6klmCounter, C7Counter, C8Counter)

    def C_5_fourth(self):
        """
        Returns a summary of the families that each conjugacy class in C_5 gets mapped to when it's raised to the fourth power.  
        """
        q = self.q
        d = self.d
        p = self.p
        C1Counter = _sage_const_0 
        C2Counter = _sage_const_0 
        C3Counter = _sage_const_0 
        C4Counter = _sage_const_0 
        C5Counter = (q+_sage_const_1 )//d-_sage_const_1 
        C6pCounter = _sage_const_0 
        C6klmCounter = _sage_const_0 
        C7Counter = _sage_const_0 
        C8Counter = _sage_const_0 
        if (q+_sage_const_1 ) % _sage_const_2  == _sage_const_0 :
            C2Counter += _sage_const_1 
            C5Counter -= _sage_const_1 
        if (q+_sage_const_1 ) % _sage_const_4  == _sage_const_0 :
            C2Counter += _sage_const_2 
            C5Counter -= _sage_const_2 
        if p == _sage_const_2 :
            C4Counter += (q+_sage_const_1 )//d-_sage_const_1 
            C5Counter-= (q+_sage_const_1 )//d-_sage_const_1 
        return (C1Counter, C2Counter, C3Counter, C4Counter, C5Counter, C6pCounter, C6klmCounter, C7Counter, C8Counter)

    def C_6_p_squared(self):
        """
        Returns a summary of the families that each conjugacy class in C_6_p gets mapped to when it's squared.  
        """
        d = self.d
        C6pCounter = _sage_const_1 -(_sage_const_3 -d)//_sage_const_2 
        C1Counter = _sage_const_0 
        C2Counter = _sage_const_0 
        C3Counter = _sage_const_0 
        C4Counter = _sage_const_0 
        C5Counter = _sage_const_0 
        C6klmCounter = _sage_const_0 
        C7Counter = _sage_const_0 
        C8Counter = _sage_const_0 
        return (C1Counter, C2Counter, C3Counter, C4Counter, C5Counter, C6pCounter, C6klmCounter, C7Counter, C8Counter)

    def C_6_p_cubed(self):
        """
        Returns a summary of the families that each conjugacy class in C_6_p gets mapped to when it's cubed.  
        """
        d = self.d
        C6pCounter = _sage_const_0 
        C1Counter = _sage_const_1 -(_sage_const_3 -d)//_sage_const_2 
        C2Counter = _sage_const_0 
        C3Counter = _sage_const_0 
        C4Counter = _sage_const_0 
        C5Counter = _sage_const_0 
        C6klmCounter = _sage_const_0 
        C7Counter = _sage_const_0 
        C8Counter = _sage_const_0 
        return (C1Counter, C2Counter, C3Counter, C4Counter, C5Counter, C6pCounter, C6klmCounter, C7Counter, C8Counter)

    def C_6_p_fourth(self):
        """
        Returns a summary of the families that each conjugacy class in C_6_p gets mapped to when it's raised to the fourth power.  
        """
        d = self.d
        C6pCounter = _sage_const_1 -(_sage_const_3 -d)//_sage_const_2 
        C1Counter = _sage_const_0 
        C2Counter = _sage_const_0 
        C3Counter = _sage_const_0 
        C4Counter = _sage_const_0 
        C5Counter = _sage_const_0 
        C6klmCounter = _sage_const_0 
        C7Counter = _sage_const_0 
        C8Counter = _sage_const_0 

        return (C1Counter, C2Counter, C3Counter, C4Counter, C5Counter, C6pCounter, C6klmCounter, C7Counter, C8Counter)


    def C_6_klm_sym_squared(self):
        """
        Returns a summary of the families that each conjugacy class in C_6_klm gets mapped to when it's squared.  
        """
        C4Counter = _sage_const_0 
        C1Counter = _sage_const_0 
        r = self.r
        if self.r % _sage_const_3  != _sage_const_0 :
            if self.r % _sage_const_2  == _sage_const_1 :
                pass
            else:
                # Case 1b
                k = math.ceil(r/_sage_const_4 )
                while k < r/_sage_const_3 :
                    k += _sage_const_1 
                    C4Counter += _sage_const_1 
                # Case 3a
                k = _sage_const_1 
                while k < r/_sage_const_6 :
                    k += _sage_const_1 
                    C4Counter += _sage_const_1 
                # Case 3b
                k = math.ceil(r/_sage_const_3 )
                while k < r/_sage_const_2 :
                    k += _sage_const_1 
                    C4Counter += _sage_const_1 
                # Case 2a 
                if self.r % _sage_const_4  == _sage_const_0 :
                    k = _sage_const_1 
                    while k < r/_sage_const_6 :
                        if k % _sage_const_2  == _sage_const_0 :
                            C4Counter += _sage_const_1 
                        k += _sage_const_1 
                else: 
                    k = _sage_const_1 
                    while k < r/_sage_const_6 :
                        if k % _sage_const_2  == _sage_const_1 :
                            C4Counter += _sage_const_1 
                        k += _sage_const_1 
        # d = 3 case
        else: 
            if self.r % _sage_const_2  == _sage_const_1 :
                pass
            else:
                # Case 3a
                k = math.ceil(r/_sage_const_12 )
                while k < r/_sage_const_6 :
                    k += _sage_const_1 
                    C4Counter += _sage_const_1 
                # Case 2a 
                if self.r % _sage_const_4  == _sage_const_0 :
                    k = _sage_const_1 
                    while k < r/_sage_const_6 :
                        if k % _sage_const_2  == _sage_const_0 :
                            C4Counter += _sage_const_1 
                        k += _sage_const_1 
                else: 
                    k = _sage_const_1 
                    while k < r/_sage_const_6 :
                        if k % _sage_const_2  == _sage_const_1 :
                            C4Counter += _sage_const_1 
                        k += _sage_const_1 

        return C4Counter # edit this so it matches the other functions' formats 

    def C_6_klm_sym_squared_explicit(self):
        """
        Returns a summary of the families that each conjugacy class in C_6_klm gets mapped to when it's squared. 
        does not iterate through each conjugacy class
        """
        a = self.r % _sage_const_12 
        r = self.r
        if a in [_sage_const_1 ,_sage_const_3 ,_sage_const_5 ,_sage_const_7 ,_sage_const_9 ,_sage_const_11 ]:
            return (_sage_const_0 ,_sage_const_0 )
        if a in [_sage_const_2 , _sage_const_10 ]:
            total = _sage_const_0  - math.ceil(r/_sage_const_4 ) + math.floor(r/_sage_const_6 ) + r/_sage_const_2   + math.ceil(math.floor(r/_sage_const_6 )/_sage_const_2 )
            return total
        if a in [_sage_const_4 , _sage_const_8 ]:
            total = -_sage_const_1  * math.floor(r/_sage_const_4 ) + math.floor(r/_sage_const_6 ) + r/_sage_const_2  + math.floor((math.ceil(r/_sage_const_6 ) - _sage_const_1 )/_sage_const_2 )
            return total
        if a == _sage_const_6 :
            return r/_sage_const_6  - _sage_const_1 
        if a == _sage_const_0 :
            return r/_sage_const_6  - _sage_const_1  
        # edit this so the return statement matches the other functions' formats 

    def C_6_klm_sym_cubed(self):
        """
        Returns a summary of the families that each conjugacy class in C_6_klm gets mapped to when it's cubed.  
        """
        C4Counter = _sage_const_0  
        r = self.r 
        if r % _sage_const_3  != _sage_const_0 :
            pass
        else: 
            # Case 2a
            k = math.ceil(r/_sage_const_6 )
            while k < _sage_const_2 *r/_sage_const_9 :
                C4Counter += _sage_const_1 
                k += _sage_const_1  
            # Case 3a 
            k = _sage_const_1 
            while k < _sage_const_2 *r/_sage_const_9 :
                if k % _sage_const_2  == _sage_const_0 :
                    C4Counter += _sage_const_1 
                k += _sage_const_1 
            # Case 2a, 3a difference = 2r/3 
            k = _sage_const_1 
            while k < r/_sage_const_9 :
                C4Counter += _sage_const_1 
                if r % _sage_const_6  == _sage_const_0  and k % _sage_const_2  == _sage_const_0 :
                    C4Counter += _sage_const_1 
                elif r % _sage_const_6  == _sage_const_3  and k % _sage_const_2  == _sage_const_1 :
                    C4Counter += _sage_const_1 
                k += _sage_const_1 
        return C4Counter # edit this so it matches the other functions' formats 

    def C_6_klm_sym_cubed_explicit(self):
        """
        Returns a summary of the families that each conjugacy class in C_6_klm gets mapped to when it's cubed. 
        does not iterate through each conjugacy class 
        """
        C4Counter = _sage_const_0 
        r = self.r
        a = r % _sage_const_12 
        if a%_sage_const_3  != _sage_const_0 :
            pass
        if a%_sage_const_6  == _sage_const_0 :
            # Case 2a
            C4Counter +=  (ceil(_sage_const_2 *r/_sage_const_9 ) - _sage_const_1 ) - ceil(r/_sage_const_6 ) + _sage_const_1 
            # Case 3a
            C4Counter += floor((ceil(_sage_const_2 *r/_sage_const_9 ) - _sage_const_1 )/_sage_const_2 )
            # Case 2a, 3a diff of 2r/3
            C4Counter += ceil(r/_sage_const_9 ) - _sage_const_1  

            
            C4Counter += floor((ceil(r/_sage_const_9 ) - _sage_const_1 )/_sage_const_2 )

        if a%_sage_const_6  == _sage_const_3 :
            # Case 2a
            C4Counter += (ceil(_sage_const_2 *r/_sage_const_9 ) - _sage_const_1 ) - ceil(r/_sage_const_6 ) + _sage_const_1 
            # Case 3a
            C4Counter += floor((ceil(_sage_const_2 *r/_sage_const_9 ) - _sage_const_1 )/_sage_const_2 )
            # Case 2a, 3a diff of 2r/3
            C4Counter += ceil(r/_sage_const_9 ) - _sage_const_1    
            C4Counter += ceil((ceil(r/_sage_const_9 ) - _sage_const_1 )/_sage_const_2 )
        return C4Counter # edit this so it matches the other functions' formats 

    def C_6_klm_sym_fourth(self):
        """
        Returns a summary of the families that each conjugacy class in C_6_klm gets mapped to when it's raised to the fourth power.  
        """
        C4Counter = _sage_const_0  
        C1Counter = _sage_const_0 
        r = self.r
        C4Counter += self.C_6_klm_sym_squared()
        if r % _sage_const_4  != _sage_const_0 :
            return C4Counter, C1Counter
        elif r % _sage_const_3  != _sage_const_0 :
            # We start by dealing with cases concerning a difference of r/4 
            # Case 1a
            print(C4Counter) 
            k = _sage_const_1  
            while k < r/_sage_const_6 : 
                C4Counter += _sage_const_1  
                k += _sage_const_1 
            print(C4Counter)
            # Case 1b
            k = math.ceil(_sage_const_3 *r/_sage_const_8 )
            while k < r/_sage_const_2 :
                C4Counter += _sage_const_1 
                k += _sage_const_1  
            print(C4Counter)
            # Case 2a 
            k = math.ceil(r/_sage_const_6 )
            while k < r/_sage_const_4 :
                k += _sage_const_1 
                C4Counter += _sage_const_1 
            print(C4Counter)
            # Case 2b 
            k = int(r/_sage_const_2 ) + _sage_const_1  
            while k < _sage_const_7  * r/_sage_const_12 :
                k += _sage_const_1  
                C4Counter += _sage_const_1  
            print(C4Counter)
            # Case 3a
            k = _sage_const_1  
            while k < r/_sage_const_4 :
                if r % _sage_const_8  == _sage_const_0  and k%_sage_const_2  == _sage_const_0 : 
                    C4Counter += _sage_const_1 
                elif r%_sage_const_8  == _sage_const_4  and k%_sage_const_2  == _sage_const_1 :
                    C4Counter += _sage_const_1 
                k += _sage_const_1 
            print(C4Counter)
            # Case 3b
            k = math.ceil(r/_sage_const_4 )
            while k < _sage_const_7 /_sage_const_12  * r:
                if r % _sage_const_8  == _sage_const_0  and k % _sage_const_2  == _sage_const_0 :
                    C4Counter += _sage_const_1  
                if r % _sage_const_8  == _sage_const_4  and k % _sage_const_2  == _sage_const_1 :
                    C4Counter += _sage_const_1 
                k += _sage_const_1  
            print(C4Counter)
            # Now we move onto cases concerning a difference of 3r/4
            # Case 1b
            k = math.ceil(r/_sage_const_8 )
            while k < r/_sage_const_6 :
                k += _sage_const_1  
                C4Counter += _sage_const_1 
            print(C4Counter)
            # Case 2a
            k = _sage_const_1 
            while k < r/_sage_const_12 :
                k += _sage_const_1  
                C4Counter += _sage_const_1 
            print(C4Counter)
            # Case 2b
            k = math.ceil(r/_sage_const_6 )
            while k <= r/_sage_const_4 : # note the '<=' weird huh?
                k += _sage_const_1 
                C4Counter += _sage_const_1 
            print(C4Counter)
            # Case 3a
            k = _sage_const_1  
            while k <= r/_sage_const_12 :
                if r%_sage_const_8  == _sage_const_0  and k % _sage_const_2  == _sage_const_0 :
                    C4Counter += _sage_const_1 
                elif r%_sage_const_8  == _sage_const_4  and k % _sage_const_2  == _sage_const_1 :
                    C4Counter += _sage_const_1 
                k += _sage_const_1  
            print(C4Counter)
            # When 4 | r we get exactly 1 C1
            C4Counter -= _sage_const_3  
            C1Counter += _sage_const_1 
            print("======================")
        else:
            # We start by dealing with cases concerning a difference of r/4 
            print(C4Counter)
            # Case 1a 
            k = _sage_const_1  
            while k <= r/_sage_const_12 : 
                C4Counter += _sage_const_1  
                k += _sage_const_1 
            print(C4Counter)
            # Case 2a 
            k = math.ceil(_sage_const_5 *r/_sage_const_24 ) # this is weird no?
            while k < r/_sage_const_4 :
                k += _sage_const_1 
                C4Counter += _sage_const_1 
            print(C4Counter)
            # Case 3a
            k = math.ceil(r/_sage_const_12 )
            while k < r/_sage_const_4 :
                if r % _sage_const_8  == _sage_const_0  and k%_sage_const_2  == _sage_const_0 : 
                    C4Counter += _sage_const_1 
                elif r%_sage_const_8  == _sage_const_4  and k%_sage_const_2  == _sage_const_1 :
                    C4Counter += _sage_const_1 
                k += _sage_const_1 
            print(C4Counter)
            # Now we move onto cases concerning a difference of 3r/4
            # Case 2a
            k = _sage_const_1 
            while k < r/_sage_const_12 :
                k += _sage_const_1  
                C4Counter += _sage_const_1 
            print(C4Counter)
            # Case 3a
            k = _sage_const_1  
            while k <= r/_sage_const_12 :
                if r%_sage_const_8  == _sage_const_0  and k % _sage_const_2  == _sage_const_0 :
                    C4Counter += _sage_const_1 
                elif r%_sage_const_8  == _sage_const_4  and k % _sage_const_2  == _sage_const_1 :
                    C4Counter += _sage_const_1 
                k += _sage_const_1  
            print(C4Counter)
            # When 4 | r we get exactly 1 C1
            C4Counter -= _sage_const_3  
            C1Counter += _sage_const_1 
            # We over counted the C1 case because there was a differnece of r/2 between k and m and so it was flagged by the squared function
            C4Counter -= _sage_const_1 
            print("============")
        return C4Counter, C1Counter # edit this so it matches the other functions' formats 

    def C_6_klm_sym_fourth_explicit(self):
        """
        Returns a summary of the families that each conjugacy class in C_6_klm gets mapped to when it's raised to the fourth power.
        does not iterate through each conjugacy class  
        """
        C4Counter = _sage_const_0 
        C1Counter = _sage_const_0 
        r = self.r
        a = r%_sage_const_24  
        C4Counter += self.C_6_klm_sym_squared_explicit()
        if a % _sage_const_4  != _sage_const_0 :
            pass
        elif a % _sage_const_3  != _sage_const_0 :
            print(C4Counter)
            # Case 1a
            C4Counter += ceil(r/_sage_const_6 ) - _sage_const_1 
            print(C4Counter)
            # Case 1b
            C4Counter += ceil(r/_sage_const_2 ) - _sage_const_1  - ceil(_sage_const_3 *r/_sage_const_8 ) + _sage_const_1 
            print(C4Counter)
            # Case 2a
            C4Counter += ceil(r/_sage_const_4 ) - _sage_const_1  - ceil(r/_sage_const_6 ) + _sage_const_1 
            print(C4Counter)
            # Case 2b
            C4Counter += ceil(_sage_const_7 *r/_sage_const_12 ) - _sage_const_1  - (int(r/_sage_const_2 ) + _sage_const_1 ) + _sage_const_1 
            print(C4Counter)
            # Case 3a 
            if a % _sage_const_8  == _sage_const_0 :
                C4Counter += floor((ceil(r/_sage_const_4 ) - _sage_const_1 )/_sage_const_2 )
            if a % _sage_const_8  == _sage_const_4 :
                C4Counter += ceil((ceil(r/_sage_const_4 ) - _sage_const_1 )/_sage_const_2 )
            print(C4Counter)
            # Case 3b
            if a % _sage_const_8  == _sage_const_0 :
                C4Counter += ceil((ceil(r*_sage_const_7 /_sage_const_12 ) - _sage_const_1  - ceil(r/_sage_const_4 ) + _sage_const_1 )/_sage_const_2 )
            if a % _sage_const_8  == _sage_const_4 :
                C4Counter += ceil((ceil(r*_sage_const_7 /_sage_const_12 ) - _sage_const_1  - ceil(r/_sage_const_4 ) + _sage_const_1 )/_sage_const_2 )
            print(C4Counter)
            # diff of 3r/4
            # Case 1b
            C4Counter += ceil(r/_sage_const_6 ) - _sage_const_1  - ceil(r/_sage_const_8 ) + _sage_const_1  
            print(C4Counter)
            # Case 2a
            C4Counter += ceil(r/_sage_const_12 ) - _sage_const_1 
            print(C4Counter)
            # Case 2b
            C4Counter += ceil(r/_sage_const_4 ) - ceil(r/_sage_const_6 ) + _sage_const_1  
            print(C4Counter)
            # Case 3a
            if a % _sage_const_8  == _sage_const_0 :
                C4Counter += floor(floor(r/_sage_const_12 )/_sage_const_2 )
            elif a % _sage_const_8  == _sage_const_4 :
                C4Counter += ceil(floor(r/_sage_const_12 )/_sage_const_2 )
            print(C4Counter)
            C4Counter -= _sage_const_3 
            C1Counter += _sage_const_1 
            print("===========================")
        elif a % _sage_const_3  == _sage_const_0 :
            print(C4Counter)
            # Case 1a 
            C4Counter += ceil(r/_sage_const_12 )
            print(C4Counter)
            # Case 2a
            C4Counter += ceil(r/_sage_const_4 ) - _sage_const_1  - ceil(_sage_const_5 *r/_sage_const_24 ) + _sage_const_1 
            print(C4Counter)
            # Case 3a
            if a % _sage_const_8  == _sage_const_0 :
                C4Counter += floor((ceil(r/_sage_const_4 ) - _sage_const_1  - ceil(r/_sage_const_12 ) + _sage_const_1 )/_sage_const_2 )
            elif r % _sage_const_8  == _sage_const_4 :
                C4Counter += ceil((ceil(r/_sage_const_4 ) - _sage_const_1  - ceil(r/_sage_const_12 ) + _sage_const_1 )/_sage_const_2 )
            print(C4Counter)
            # diff of 3r/4
            # Case 2a
            C4Counter += ceil(r/_sage_const_12 ) - _sage_const_1 
            print(C4Counter)
            # Case 3a 
            if a % _sage_const_8  == _sage_const_0 :
                C4Counter += floor(floor(r/_sage_const_12 )/_sage_const_2 )
            elif a % _sage_const_8  == _sage_const_4 :
                C4Counter += ceil(floor(r/_sage_const_12 )/_sage_const_2 )
            print(C4Counter)

            C4Counter -= _sage_const_4 
            C1Counter += _sage_const_1 
            print("===========")

        return C4Counter, C1Counter # edit this so it matches the other functions' formats 
        
    
    def C_7_squared(self):
        """
        Returns a summary of the families that each conjugacy class in C_7 gets mapped to when it's squared.  
        """
        p = self.p
        q = self.q
        d = self.d
        totalnum = (q*q-q+_sage_const_1 -d)//(_sage_const_2 *self.d) - (_sage_const_3 -d)//_sage_const_2 
        C1Counter = _sage_const_0 
        C2Counter = _sage_const_0 
        C3Counter = _sage_const_0 
        C4Counter = _sage_const_0 
        C5Counter = _sage_const_0 
        C6pCounter = _sage_const_0 
        C6klmCounter = _sage_const_0 
        C7Counter = totalnum
        C8Counter = _sage_const_0 
        if q % _sage_const_2  != _sage_const_0 :
            C4Counter += (q+_sage_const_1 )//(_sage_const_2 *self.d)
            C7Counter = C7Counter - (q+_sage_const_1 )//(_sage_const_2 *self.d)
        return (C1Counter, C2Counter, C3Counter, C4Counter, C5Counter, C6pCounter, C6klmCounter, C7Counter, C8Counter)

    def C_7_cubed(self):
        """
        Returns a summary of the families that each conjugacy class in C_7 gets mapped to when it's cubed.  
        """
        p = self.p
        q = self.q
        d = self.d
        totalnum = (q*q-q+_sage_const_1 -d)//(_sage_const_2 *self.d) - (_sage_const_3 -d)//_sage_const_2 
        C1Counter = _sage_const_0 
        C2Counter = _sage_const_0 
        C3Counter = _sage_const_0 
        C4Counter = _sage_const_0 
        C5Counter = _sage_const_0 
        C6pCounter = _sage_const_0 
        C6klmCounter = _sage_const_0 
        C7Counter = totalnum
        C8Counter = _sage_const_0 
        if q % _sage_const_3  == _sage_const_1 :
            C1Counter += _sage_const_1 
            C7Counter -= _sage_const_1 
            C4Counter += q
            C7Counter -= q
        return (C1Counter, C2Counter, C3Counter, C4Counter, C5Counter, C6pCounter, C6klmCounter, C7Counter, C8Counter)

    def C_7_fourth(self):
        """
        Returns a summary of the families that each conjugacy class in C_7 gets mapped to when it's raised to the fourth power.  
        """
        p = self.p
        q = self.q
        d = self.d
        totalnum = (q*q-q+_sage_const_1 -d)//(_sage_const_2 *self.d) - (_sage_const_3 -d)//_sage_const_2 
        C1Counter = _sage_const_0 
        C2Counter = _sage_const_0 
        C3Counter = _sage_const_0 
        C4Counter = _sage_const_0 
        C5Counter = _sage_const_0 
        C6pCounter = _sage_const_0 
        C6klmCounter = _sage_const_0 
        C7Counter = totalnum
        C8Counter = _sage_const_0 
        if q % _sage_const_2  == _sage_const_1 :
            C4Counter += (q+_sage_const_1 )//(_sage_const_2 *self.d)
            C7Counter -= (q+_sage_const_1 )//(_sage_const_2 *self.d)
        if q % _sage_const_4  == _sage_const_1 : 
            C4Counter += _sage_const_2 *(q+_sage_const_1 )//(_sage_const_2 *self.d)
            C7Counter -= _sage_const_2 *(q+_sage_const_1 )//(_sage_const_2 *self.d)
        if (q+_sage_const_1 ) % _sage_const_2  == _sage_const_0  and (q+_sage_const_1 )%_sage_const_4  != _sage_const_0 :
            C1Counter += _sage_const_1 
            C4Counter -= _sage_const_1 
        return (C1Counter, C2Counter, C3Counter, C4Counter, C5Counter, C6pCounter, C6klmCounter, C7Counter, C8Counter)
    
    def C_8_squared(self):
        """
        Returns a summary of the families that each conjugacy class in C_8 gets mapped to when it's squared.  
        """
        q = self.q
        d = self.d
        C1Counter = _sage_const_0 
        C2Counter = _sage_const_0 
        C3Counter = _sage_const_0 
        C4Counter = _sage_const_0 
        C5Counter = _sage_const_0 
        C6pCounter = _sage_const_0 
        C6klmCounter = _sage_const_0 
        C7Counter = _sage_const_0 
        C8Counter = ((q*q-q+_sage_const_1 )//d-_sage_const_1 )//_sage_const_3 
        return (C1Counter, C2Counter, C3Counter, C4Counter, C5Counter, C6pCounter, C6klmCounter, C7Counter, C8Counter)
    
    def C_8_cubed(self):
        """
        Returns a summary of the families that each conjugacy class in C_8 gets mapped to when it's cubed.  
        """
        q = self.q
        d = self.d
        C1Counter = _sage_const_0 
        C2Counter = _sage_const_0 
        C3Counter = _sage_const_0 
        C4Counter = _sage_const_0 
        C5Counter = _sage_const_0 
        C6pCounter = _sage_const_0 
        C6klmCounter = _sage_const_0 
        C7Counter = _sage_const_0 
        C8Counter = ((q*q-q+_sage_const_1 )//d-_sage_const_1 )//_sage_const_3 
        return (C1Counter, C2Counter, C3Counter, C4Counter, C5Counter, C6pCounter, C6klmCounter, C7Counter, C8Counter)
    
    def C_8_fourth(self):
        """
        Returns a summary of the families that each conjugacy class in C_8 gets mapped to when it's raised to the fourth power.  
        """
        q = self.q
        d = self.d
        C1Counter = _sage_const_0 
        C2Counter = _sage_const_0 
        C3Counter = _sage_const_0 
        C4Counter = _sage_const_0 
        C5Counter = _sage_const_0 
        C6pCounter = _sage_const_0 
        C6klmCounter = _sage_const_0 
        C7Counter = _sage_const_0 
        C8Counter = ((q*q-q+_sage_const_1 )//d-_sage_const_1 )//_sage_const_3 
        return (C1Counter, C2Counter, C3Counter, C4Counter, C5Counter, C6pCounter, C6klmCounter, C7Counter, C8Counter)


        



def primes_up_to(k):
    """
    returns an ascending list of all primes up through k
    """
    primes = [_sage_const_2 ]
    for i in range(_sage_const_3 ,k):
        for p in primes:
            if i%p == _sage_const_0 : break
        else:
            primes.append(i)
    return(primes)

start = time.time()




G = GroupCharactersPSL3(_sage_const_7 , _sage_const_1 )
print(G.characters[_sage_const_0 ])
print(G.the_game(G.characters[_sage_const_0 ], _sage_const_4 ))

# G = GroupCharactersPSU3(3,6)
# print(G.class_order)
# G.display()
# print(G.the_game(G.characters[0], 10))
# H = GroupCharacters("PSU(3, 3)")
# print(H.the_game(H.characters[1], 10))
# print(H.the_game(H.characters[1], 10))
# H.display()

# currently fails for q = 125, 4, 8, 3, 7, 27 -- struggling with third powers, small primes, and a couple other things?
# Works for: q = 2, 5, 25, 16, 32, 49, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47
end = time.time()
print(f"Elapsed time: {end - start:.4f} seconds")   
i = _sage_const_0 
G = GroupCharactersPSU3(_sage_const_5 , _sage_const_2 )
for g in G.classes:
    if g[_sage_const_2 ] == "6":
        if G.power_of(g, _sage_const_2 )[_sage_const_2 ] != "6":
            print(g)
            print(f"g squared is {G.power_of(g, _sage_const_2 )}")
            i += _sage_const_1 
print(i)
print(G.C_6_klm_sym_squared())
print(G.C_6_klm_sym_squared_explicit())

i1 = _sage_const_0 
i2 = _sage_const_0 
i3 = _sage_const_0 
i4 = _sage_const_0 
i5 = _sage_const_0 
i6p = _sage_const_0 
i6klm = _sage_const_0 
i7 = _sage_const_0 
i8 = _sage_const_0 


i = _sage_const_0 
G = GroupCharactersPSU3(_sage_const_47 , _sage_const_1 )

for g in G.classes:
    if g[_sage_const_2 ] == "6" and g[_sage_const_3 ] != "'":
        if G.power_of(g, _sage_const_4 )[_sage_const_2 ] != "6":
            print(g)
            print(f"g fourth is {G.power_of(g, _sage_const_4 )}")
            i += _sage_const_1 
print(f"empirical problem cases (fourth): {i}")
print(f"predicted problem cases (fourth): {G.C_6_klm_sym_fourth()}")
print(G.C_6_klm_sym_fourth_explicit())


"""
i = 0
G = GroupCharactersPSU3(11, 1)
power_map_counts = {'1': {}, '2': {}, '3': {}, '4': {}, '5': {}, '6': {}, '7': {}, '8': {}}
for g in G.classes:
    if G.power_of(g, 4)[2] not in power_map_counts[g[2]].keys():
        power_map_counts[g[2]][G.power_of(g, 4)[2]] = 1
    else:
        power_map_counts[g[2]][G.power_of(g, 4)[2]] += 1
print(power_map_counts)
# print(f"empirical problem cases (cube): {i}")
# print(f"predicted problem cases (cube): {G.C_8_cubed()}")
"""
G = GroupCharactersPSU3(_sage_const_3 , _sage_const_1 )
"""
i = 0
for g in G.classes:
    if g[2] == "6" and g[3] != "'":
        if G.power_of(g, 4)[2] != "6":
            print(g)
            print(f"g to the fourth is {G.power_of(g, 4)}")
            i += 1
print(f"empirical problem cases (4th): {i}")
print(f"predicted problem cases (4th): {G.C_6_klm_sym_fourth()}")
print(f"predicted problem cases explicit (4th): {G.C_6_klm_sym_fourth_explicit()}")
"""
H = GroupCharacters("PSU(3, 3)")
H.display()
G.display()



