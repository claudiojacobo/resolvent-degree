

# This file was *autogenerated* from the file group_characters.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_4 = Integer(4); _sage_const_5 = Integer(5); _sage_const_7 = Integer(7); _sage_const_8 = Integer(8); _sage_const_9 = Integer(9); _sage_const_11 = Integer(11); _sage_const_13 = Integer(13); _sage_const_16 = Integer(16); _sage_const_17 = Integer(17); _sage_const_19 = Integer(19); _sage_const_23 = Integer(23); _sage_const_25 = Integer(25); _sage_const_27 = Integer(27); _sage_const_29 = Integer(29); _sage_const_31 = Integer(31); _sage_const_32 = Integer(32); _sage_const_37 = Integer(37); _sage_const_39 = Integer(39); _sage_const_41 = Integer(41); _sage_const_43 = Integer(43); _sage_const_47 = Integer(47); _sage_const_49 = Integer(49)
import math
from sage.all import libgap # is this necessary? 
import time
load("helper_functions.sage")

class GroupCharacters:
    name = None # string
    classes = None # list of strings
    class_order = None # dictionary string->int
    centralizer_order = None # dictionary string->int
    group_order = None # int
    primes = None # list of ints
    power_map = None # dictionary string->dictionary (int->string)
    characters = None # list of dictionaries string->algebraic number
    minimal_perm = None # int
    
    def __init__(self, group_name):
        # invoke GAP via libgap
        self.name = group_name
        group = eval(f"libgap.{group_name}")
        ct = group.CharacterTable()
        self.classes = libgap.ClassNames(ct).sage()
        r = len(self.classes)

        # parse orders of each conjugacy class representative
        orders = ct.OrdersClassRepresentatives().sage()
        self.class_order = { self.classes[i]:orders[i] for i in range(r) }

        # parse centralizer orders
        centralizers = ct.SizesCentralizers().sage()
        self.centralizer_order = { self.classes[i]:centralizers[i] for i in range(r) }
        self.group_order = centralizers[_sage_const_0 ]
 
        # load necessary power maps
        largest_order = max(orders)
        self.primes = primes_up_to(largest_order)
        self.power_map = { g:{} for g in self.classes }
        for p in self.primes:
            for i in range(len(self.classes)):
                self.power_map[self.classes[i]][p] = self.classes[ct.PowerMap(p).sage()[i]-_sage_const_1 ]

        # sort characters by degree
        ct = sorted(ct.Irr().sage(), key=lambda x:x[_sage_const_0 ])
        self.characters = [ { self.classes[i]:chi[i] for i in range(r) } for chi in ct]

        # this is likely a bottleneck
        self.minimal_perm = group.MinimalFaithfulPermutationDegree()

    def display(self, decimal=False):
        print(f"----------- Character data for {self.name} ------------")
        
        print("\nConjugacy classes:\n\n", end="\t")
        for g in self.classes:
            print(g,end = "\t")

        print("\n\nCentralizers:\n\n", end="\t")
        for g in self.classes:
            print(self.centralizer_order[g],end = "\t")

        print("\n\nPower maps:")
        for p in self.primes:
            print(f"\n{p}", end="\t")
            for g in self.classes:
                print(self.power_map[g][p],end = "\t")

        print("\n\nCharacters:")
        for i, chi in enumerate(self.characters):
            print(f"\nÏ‡{i}:", end="\t")
            for g in self.classes:
                if decimal:
                    print(f"{complex(chi[g]):.3f}",end = "\t")
                else:
                    print(chi[g],end = "\t")
        print("\n")

    def inner_product(self, f1, f2):
        """
        compute the inner product of two class functions (encoded as dictionaries with keys = classes)
        """
        return sum([ f1[g].conjugate()*f2[g]/self.centralizer_order[g] for g in self.classes ])
 
    def invariant_dimension(self, chi):
        """
        computes the dimension of G-invariants for the representation corresponding to chi
        """
        return sum([ chi[g]/self.centralizer_order[g] for g in self.classes ])

    def eval_char(self, chi, conj, n):
        """
        Evaluates a specific character at a conjugacy class raised to the nth power.
        :param chi: Relevant character dictionary
        :param conj: conjugacy class of interest
        :param n: Power we raise conj to
        :return: 
        """
        m = n % self.class_order[conj]
        prime_factorization = []
        i = _sage_const_0 
        if m == _sage_const_0 :
            return chi[self.classes[_sage_const_0 ]]
        while i < len(self.primes):
            if m % self.primes[i] == _sage_const_0 :
                m = m / self.primes[i]
                prime_factorization.append(self.primes[i])
            else:
                i += _sage_const_1 
        curr_class = conj
        for num in prime_factorization:
            curr_class = self.power_map[curr_class][num]

        return chi[curr_class]

    def sym_power(self, chi, k):
        """
        Computes the character of the kth symmetric power of an action. 
        :k: an integer greater than 0 representing the dimension of the symmetric power
        :return: a dictionary whose keys are conjugacy classes and whose values are (sage?) numbers
        """
        sym_power = {}
        for g in self.classes:
            sum = _sage_const_0 
            for partition in partition_tuple(k):
                product = _sage_const_1 
                for i in range(_sage_const_1 , k+_sage_const_1 ):
                    product *= (((self.eval_char(chi, g, i)) ** partition[i]) *
                                (_sage_const_1  / ((math.factorial(partition[i])) * (i ** partition[i]))))
                sum += product
            sym_power[g] = sum
        return(sym_power)
        
    def get_coef(self, chi, k): 
        '''
        first makes a list of dictionaries from symmetric power function and calculates
        the inner product..outputs a list of the coef where position of the list 
        corresponds to kth power'''
        sym_pows = []
        for i in range(_sage_const_0 ,k): # check for off by 1 errors abd what sym^0 is
            sym_pows.append(self.sym_power(chi,i))
        molien_coefs = [_sage_const_1 ]
        for i in range(_sage_const_1 ,k): 
            molien_coefs.append(self.invariant_dimension(sym_pows[i])) 
            #maybe we call ct, not sure about naming
        return molien_coefs 

    def power_class(self, g, k):
        """
        Recursively computes the conjugacy class of g^k using power map data
        """
        k = k % self.class_order[g]
        if k == _sage_const_0 :
            return self.classes[_sage_const_0 ] # Assumes 0th class is the identity
        elif k == _sage_const_1 :
            return g
        for p in self.primes:
            if k%p == _sage_const_0 :
                return self.power_class(self.power_map[g][p],k//p)

    def molien_coeff(self, chi, k): 
        """
        Returns the first k coefficients of the Molien series for chi
        """
        sym = [{ g:_sage_const_1  for g in self.classes }, chi]
        for i in range(_sage_const_2 ,k):
            sym.append({})
            for g in self.classes:
                sym[i][g] = sum([ sym[i-_sage_const_1 -j][g] * chi[self.power_class(g,j+_sage_const_1 )] for j in range(i)])/i
        return [ self.invariant_dimension(char) for char in sym ]

    def print_chars(self):
        for character in self.characters:
            print(character)
            print("")

    def print_char(self, k):
        print(self.characters[k])
    
    def the_game(self, chi, n):
        """
        Calculates a bound on G using chi and theorems about nice G-varieties 
        returns triple (bound, ran_out_of_molien, limited_by_subgroup) where the first entry is an integer
        and the second and there are booleans indicating (2) wether or not we had enough molien series terms 
        to finish our calculations and (3) wether we were limited by the size of our maximal subgroup or by
        the product of the degrees of invariant polynomials.
        """
        bound = chi[self.classes[_sage_const_0 ]] - _sage_const_1  # sets initial bound to dimension of the associated projective rep
        degree_product = _sage_const_1  
        alg_indp_poly = generators_from_molien(self.molien_coeff(chi, n))
        ran_out_of_molien = True
        limited_by_action = False
        limited_by_versality = False
        beat_by_perm = False
        invariants = []

        alg_indp_poly_copy = tuple(alg_indp_poly)
        alg_indp_poly_copy = list(alg_indp_poly_copy)
        for i, val in enumerate(alg_indp_poly_copy):
            alg_indp_poly_copy[i] = str(val)
        i = _sage_const_1 
        # start at the first non zero entry in alg_indp_poly
        while i < len(alg_indp_poly) and alg_indp_poly[i] == _sage_const_0 :
            i += _sage_const_1 
        while i < len(alg_indp_poly):
            if degree_product * i >= self.minimal_perm: # failed b/c irreducibility
                limited_by_action = True
                ran_out_of_molien = False
                if RD(degree_product * i) > bound-_sage_const_1 : # also failed b/c versality
                    limited_by_versality = True
                else: # truly failed b/c irreducibility
                    invariants.append(int(i))
                break 
            
            # Stop when product of degrees is larger than bound
            if RD(degree_product * i) > bound-_sage_const_1 :
                ran_out_of_molien = False
                limited_by_versality = True
                break

            bound -= _sage_const_1 
            degree_product *= i
            invariants.append(int(i))
            alg_indp_poly[i] -= _sage_const_1 
            while i < len(alg_indp_poly) and alg_indp_poly[i] == _sage_const_0 :
                i += _sage_const_1 

        if RD(self.minimal_perm) <= bound:
            beat_by_perm = True 
            if RD(self.minimal_perm) < bound:
                limited_by_action = False
                limited_by_versality = False
                bound = RD(self.minimal_perm)


        output = {
            "group":self.name, 
            "rep-degree":int(chi[self.classes[_sage_const_0 ]]), 
            "bound":int(bound), 
            "invariants":tuple(invariants),
            "total polynomials":alg_indp_poly_copy,
            "limitation":[], 
            "notes":"",
        }
        if limited_by_action:
            output["limitation"].append("generic-freeness")
        if limited_by_versality:
            output["limitation"].append("versality-degree")
        if beat_by_perm:
            output["limitation"].append("permutation-rep")
        if ran_out_of_molien and RD(degree_product * (n-_sage_const_1 )) < bound:
            output["limitation"].append("insufficient-invariants")
            print(f"{self.name} We ran out of Molien terms before the game ended!")

        return output


for i in [_sage_const_2 ,_sage_const_3 ,_sage_const_4 ,_sage_const_5 ,_sage_const_7 ,_sage_const_8 ,_sage_const_9 ,_sage_const_11 ,_sage_const_13 ,_sage_const_16 ,_sage_const_17 ,_sage_const_19 ,_sage_const_23 ,_sage_const_25 ,_sage_const_27 ,_sage_const_29 ,_sage_const_31 ,_sage_const_32 ,_sage_const_37 ,_sage_const_39 ,_sage_const_41 ,_sage_const_43 ,_sage_const_47 ,_sage_const_49 ]:
    G = GroupCharacters(f"PSL(3, {i})")
    print(G.the_game(G.characters[_sage_const_1 ], _sage_const_9 )) 


